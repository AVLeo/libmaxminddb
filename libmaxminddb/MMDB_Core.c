#include "MMDB.h"
#include <arpa/inet.h>
#include <assert.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#if HAVE_CONFIG_H
#include <config.h>
#endif

#if MMDB_DEBUG
#define LOCAL
#else
#define LOCAL static
#endif

typedef union {
    struct in_addr v4;
    struct in6_addr v6;
} in_addr_any;

#define MMDB_CHKBIT_128(bit,ptr) ((ptr)[((127U - (bit)) >> 3)] & (1U << (~(127U - (bit)) & 7)))

#define RETURN_ON_END_OF_SEARCHX(offset, segments, depth, maxdepth, res)   \
    if ((offset) >= (segments)) {                                       \
        (res)->netmask = (maxdepth) - (depth);                          \
        (res)->entry.offset = (offset) - (segments);                    \
        return MMDB_SUCCESS;                                            \
    }

#define RETURN_ON_END_OF_SEARCH32(offset, segments, depth, res)           \
    MMDB_DBG_CARP( "RETURN_ON_END_OF_SEARCH32 depth:%d offset:%u segments:%d\n", depth, (unsigned int)offset, segments); \
    RETURN_ON_END_OF_SEARCHX(offset,segments,depth, 32, res)

#define RETURN_ON_END_OF_SEARCH128(offset, segments, depth, res)  \
    RETURN_ON_END_OF_SEARCHX(offset,segments,depth,128, res)

#define METADATA_MARKER "\xab\xcd\xefMaxMind.com"
#define METADATA_BLOCK_MAX_SIZE 20000

/* --prototypes automatically generated by dev-bin/regen-prototypes.pl - don't remove this comment */
LOCAL int resolve_any_address(const char *ipstr, int is_ipv4,
                              in_addr_any *in_addr);
LOCAL void populate_description_metadata(MMDB_s *mmdb);
LOCAL int read_metadata(MMDB_s *mmdb, uint8_t *metadata_content, ssize_t size);
LOCAL uint32_t value_for_key_as_uint32(MMDB_entry_s *start, char *key);
LOCAL uint64_t value_for_key_as_uint64(MMDB_entry_s *start, char *key);
LOCAL uint64_t c8_to_uint64(uint8_t c8[]);
LOCAL char *value_for_key_as_string(MMDB_entry_s *start, char *key);
LOCAL void populate_languages_metadata(MMDB_s *mmdb);
LOCAL uint16_t init(MMDB_s *mmdb, const char *fname, uint32_t flags);
LOCAL void free_all(MMDB_s *mmdb);
LOCAL char *bytesdup(MMDB_return_s const *const ret);
LOCAL void skip_hash_array(MMDB_s *mmdb, MMDB_decode_s *decode);
LOCAL void decode_one_follow(MMDB_s *mmdb, uint32_t offset,
                             MMDB_decode_s *decode);
LOCAL void decode_one(MMDB_s *mmdb, uint32_t offset, MMDB_decode_s *decode);
LOCAL int get_ext_type(int raw_ext_type);
LOCAL void DPRINT_KEY(MMDB_s *mmdb, MMDB_return_s *data);
LOCAL uint32_t get_ptr_from(uint8_t ctrl, uint8_t const *const ptr,
                            int ptr_size);
LOCAL void get_tree(MMDB_s *mmdb, uint32_t offset, MMDB_decode_all_s *decode);
LOCAL void silly_pindent(int i);
LOCAL float get_ieee754_float(const uint8_t *restrict p);
LOCAL double get_ieee754_double(const uint8_t *restrict p);
LOCAL uint32_t get_uint32(const uint8_t *p);
LOCAL uint32_t get_uint24(const uint8_t *p);
LOCAL uint32_t get_uint16(const uint8_t *p);
LOCAL uint32_t get_uintX(const uint8_t *p, int length);
LOCAL int get_sintX(const uint8_t *p, int length);
LOCAL int int_pread(int fd, uint8_t *buffer, ssize_t to_read, off_t offset);
LOCAL MMDB_decode_all_s *dump(MMDB_s *mmdb, MMDB_decode_all_s *decode_all,
                              int indent);
/* --prototypes end - don't remove this comment-- */

#if !defined HAVE_MEMMEM
LOCAL void *memmem(const void *big, size_t big_len, const void *little,
                   size_t little_len)
{
    if (little_len) {
        int first_char = ((uint8_t *)little)[0];
        const void *ptr = big;
        size_t len = big_len;
        while (len >= little_len
               && (ptr = memchr(ptr, first_char, len - little_len + 1))) {
            if (!memcmp(ptr, little, little_len)) {
                return (void *)ptr;
            }
            len = big_len - (++ptr - big);
        }
    }
    return NULL;
}
#endif

int MMDB_resolve_address(const char *host, int ai_family, int ai_flags,
                         void *ip)
{
    struct addrinfo hints = {.ai_family = ai_family,
        .ai_flags = ai_flags,
        .ai_socktype = SOCK_STREAM
    }, *aifirst;
    int gaierr = getaddrinfo(host, NULL, &hints, &aifirst);

    if (gaierr == 0) {
        if (ai_family == AF_INET) {
            memcpy(&((struct in_addr *)ip)->s_addr,
                   &((struct sockaddr_in *)aifirst->ai_addr)->sin_addr, 4);
        } else if (ai_family == AF_INET6) {
            memcpy(&((struct in6_addr *)ip)->s6_addr,
                   ((struct sockaddr_in6 *)aifirst->ai_addr)->sin6_addr.s6_addr,
                   16);

        } else {
            /* should never happen */
            assert(0);
        }
        freeaddrinfo(aifirst);
    }
    return gaierr;
}

MMDB_lookup_result_s *MMDB_lookup(MMDB_s *mmdb, const char *ipstr,
                                  int *gai_error, int *mmdb_error)
{
    int is_ipv4 = mmdb->metadata.ip_version == 4 ? 1 : 0;
    in_addr_any in_addr;

    MMDB_lookup_result_s *root = malloc(sizeof(MMDB_lookup_result_s *));
    assert(root != NULL);

    root->entry.mmdb = mmdb;

    *gai_error = resolve_any_address(ipstr, is_ipv4, &in_addr);

    if (*gai_error) {
        return NULL;
    }

    if (is_ipv4) {
        *mmdb_error = MMDB_lookup_by_ipnum(in_addr.v4.s_addr, root);
    } else {
        *mmdb_error = MMDB_lookup_by_ipnum_128(in_addr.v6, root);
    }

    if (*mmdb_error) {
        return NULL;
    }

    if (root->entry.offset > 0) {
        return root;
    } else {
        return NULL;
    }
}

LOCAL int resolve_any_address(const char *ipstr, int is_ipv4,
                              in_addr_any *in_addr)
{
    int ai_flags = AI_NUMERICHOST;
    struct addrinfo hints = {
        .ai_socktype = SOCK_STREAM
    };
    struct addrinfo *addresses;
    int gai_status;

    if (is_ipv4) {
        hints.ai_flags = ai_flags;
        hints.ai_family = AF_INET;
    } else {
        hints.ai_flags = ai_flags | AI_V4MAPPED;
        hints.ai_family = AF_INET6;
    }

    gai_status = getaddrinfo(ipstr, NULL, &hints, &addresses);
    if (gai_status) {
        return gai_status;
    }

    if (hints.ai_family == AF_INET) {
        memcpy(&((struct in_addr *)in_addr)->s_addr,
               &((struct sockaddr_in *)addresses->ai_addr)->sin_addr.s_addr, 4);
    } else if (hints.ai_family == AF_INET6) {
        memcpy(&((struct in6_addr *)in_addr)->s6_addr,
               ((struct sockaddr_in6 *)addresses->ai_addr)->sin6_addr.s6_addr,
               16);
    } else {
        /* This should never happen */
        assert(0);
    }

    freeaddrinfo(addresses);

    return 0;
}

int MMDB_lookup_by_ipnum_128(struct in6_addr ipnum,
                             MMDB_lookup_result_s *result)
{
    MMDB_s *mmdb = result->entry.mmdb;

    int segments = mmdb->metadata.node_count;
    uint32_t offset = 0;
    int rl = mmdb->full_record_byte_size;
    const uint8_t *mem = mmdb->file_in_mem_ptr;
    const uint8_t *p;
    int depth;
    if (rl == 6) {
        for (depth = mmdb->depth - 1; depth >= 0; depth--) {
            p = &mem[offset * rl];
            if (MMDB_CHKBIT_128(depth, (uint8_t *)&ipnum)) {
                p += 3;
            }
            offset = get_uint24(p);
            RETURN_ON_END_OF_SEARCH128(offset, segments, depth, result);
        }
    } else if (rl == 7) {
        for (depth = mmdb->depth - 1; depth >= 0; depth--) {
            p = &mem[offset * rl];
            if (MMDB_CHKBIT_128(depth, (uint8_t *)&ipnum)) {
                p += 3;
                offset = get_uint32(p);
                offset &= 0xfffffff;
            } else {
                offset =
                    p[0] * 65536 + p[1] * 256 + p[2] + ((p[3] & 0xf0) << 20);
            }
            RETURN_ON_END_OF_SEARCH128(offset, segments, depth, result);
        }
    } else if (rl == 8) {
        for (depth = mmdb->depth - 1; depth >= 0; depth--) {
            p = &mem[offset * rl];
            if (MMDB_CHKBIT_128(depth, (uint8_t *)&ipnum)) {
                p += 4;
            }
            offset = get_uint32(p);
            RETURN_ON_END_OF_SEARCH128(offset, segments, depth, result);
        }
    }
    //uhhh should never happen !
    return MMDB_CORRUPT_DATABASE;
}

int MMDB_lookup_by_ipnum(uint32_t ipnum, MMDB_lookup_result_s *res)
{
    MMDB_s *mmdb = res->entry.mmdb;

    int segments = mmdb->metadata.node_count;
    uint32_t offset = 0;
    int rl = mmdb->full_record_byte_size;
    const uint8_t *mem = mmdb->file_in_mem_ptr;
    const uint8_t *p;
    uint32_t mask = 0x80000000U;
    int depth;
    if (rl == 6) {
        for (depth = 32 - 1; depth >= 0; depth--, mask >>= 1) {
            p = &mem[offset * rl];
            if (ipnum & mask) {
                p += 3;
            }
            offset = get_uint24(p);
            RETURN_ON_END_OF_SEARCH32(offset, segments, depth, res);
        }
    } else if (rl == 7) {
        for (depth = 32 - 1; depth >= 0; depth--, mask >>= 1) {
            p = &mem[offset * rl];
            if (ipnum & mask) {
                p += 3;
                offset = get_uint32(p);
                offset &= 0xfffffff;
            } else {
                offset =
                    p[0] * 65536 + p[1] * 256 + p[2] + ((p[3] & 0xf0) << 20);
            }
            RETURN_ON_END_OF_SEARCH32(offset, segments, depth, res);
        }
    } else if (rl == 8) {
        for (depth = 32 - 1; depth >= 0; depth--, mask >>= 1) {
            p = &mem[offset * rl];
            if (ipnum & mask) {
                p += 4;
            }
            offset = get_uint32(p);
            RETURN_ON_END_OF_SEARCH32(offset, segments, depth, res);
        }
    }
    //uhhh should never happen !
    return MMDB_CORRUPT_DATABASE;
}

LOCAL void populate_description_metadata(MMDB_s *mmdb)
{
    MMDB_return_s result;
    MMDB_entry_s map_start;
    size_t map_size;
    MMDB_decode_all_s *member;
    MMDB_decode_all_s *first_member;
    int i;

    MMDB_get_value(&mmdb->meta, &result, "description", NULL);

    assert(result.type == MMDB_DTYPE_MAP);

    map_start.mmdb = mmdb->fake_metadata_db;
    map_start.offset = result.offset;

    MMDB_get_tree(&map_start, &member);

    first_member = member;

    map_size = member->decode.data.data_size;
    mmdb->metadata.description.count = map_size;
    mmdb->metadata.description.descriptions =
        malloc(map_size * sizeof(MMDB_description_s *));

    for (i = 0; i < map_size; i++) {
        mmdb->metadata.description.descriptions[i] =
            malloc(sizeof(MMDB_description_s));

        member = member->next;
        assert(member->decode.data.type == MMDB_DTYPE_UTF8_STRING);
        mmdb->metadata.description.descriptions[i]->language =
            strndup((char *)member->decode.data.ptr,
                    member->decode.data.data_size);

        member = member->next;
        assert(member->decode.data.type == MMDB_DTYPE_UTF8_STRING);
        mmdb->metadata.description.descriptions[i]->description =
            strndup((char *)member->decode.data.ptr,
                    member->decode.data.data_size);
    }

    MMDB_free_decode_all(first_member);
}

LOCAL int read_metadata(MMDB_s *mmdb, uint8_t *metadata_content, ssize_t size)
{
    const uint8_t *metadata = memmem(metadata_content, size, METADATA_MARKER,
                                     strlen(METADATA_MARKER));
    if (NULL == metadata) {
        return MMDB_INVALID_DATABASE;
    }

    mmdb->fake_metadata_db = calloc(1, sizeof(struct MMDB_s));
    assert(mmdb->fake_metadata_db != NULL);

    mmdb->fake_metadata_db->dataptr = metadata + strlen(METADATA_MARKER);
    mmdb->meta.mmdb = mmdb->fake_metadata_db;

    mmdb->metadata.node_count =
        value_for_key_as_uint32(&mmdb->meta, "node_count");

    mmdb->metadata.record_size =
        value_for_key_as_uint32(&mmdb->meta, "record_size");

    mmdb->metadata.ip_version =
        value_for_key_as_uint32(&mmdb->meta, "ip_version");

    mmdb->metadata.database_type =
        value_for_key_as_string(&mmdb->meta, "database_type");

    populate_languages_metadata(mmdb);

    mmdb->metadata.binary_format_major_version =
        value_for_key_as_uint32(&mmdb->meta, "binary_format_major_version");

    mmdb->metadata.binary_format_minor_version =
        value_for_key_as_uint32(&mmdb->meta, "binary_format_minor_version");

    mmdb->metadata.build_epoch =
        value_for_key_as_uint64(&mmdb->meta, "build_epoch");

    populate_description_metadata(mmdb);

    mmdb->full_record_byte_size =
        value_for_key_as_uint32(&mmdb->meta, "record_size") * 2 / 8U;

    mmdb->depth = mmdb->metadata.ip_version == 4 ? 32 : 128;

    return MMDB_SUCCESS;
}

LOCAL uint32_t value_for_key_as_uint32(MMDB_entry_s *start, char *key)
{
    MMDB_return_s result;
    MMDB_get_value(start, &result, key, NULL);
    return result.uinteger;
}

LOCAL uint64_t value_for_key_as_uint64(MMDB_entry_s *start, char *key)
{
    MMDB_return_s result;
    MMDB_get_value(start, &result, key, NULL);
    return c8_to_uint64(result.c8);
}

LOCAL uint64_t c8_to_uint64(uint8_t c8[])
{
    uint64_t value = 0;
    for (int i = 0; i < 8; i++) {
        value <<= 8;
        value += c8[i];
    }

    return value;
}

LOCAL char *value_for_key_as_string(MMDB_entry_s *start, char *key)
{
    MMDB_return_s result;
    MMDB_get_value(start, &result, key, NULL);
    return strndup((char *)result.ptr, result.data_size);
}

LOCAL void populate_languages_metadata(MMDB_s *mmdb)
{
    MMDB_return_s result;
    MMDB_entry_s array_start;
    size_t array_size;
    MMDB_decode_all_s *member;
    MMDB_decode_all_s *first_member;
    int i;

    MMDB_get_value(&mmdb->meta, &result, "languages", NULL);

    assert(result.type == MMDB_DTYPE_ARRAY);

    array_start.mmdb = mmdb->fake_metadata_db;
    array_start.offset = result.offset;

    MMDB_get_tree(&array_start, &member);

    first_member = member;

    array_size = member->decode.data.data_size;
    mmdb->metadata.languages.count = array_size;
    mmdb->metadata.languages.names = malloc(array_size * sizeof(char *));

    for (i = 0; i < array_size; i++) {
        member = member->next;
        assert(member->decode.data.type == MMDB_DTYPE_UTF8_STRING);

        mmdb->metadata.languages.names[i] =
            strndup((char *)member->decode.data.ptr,
                    member->decode.data.data_size);
        assert(mmdb->metadata.languages.names[i] != NULL);
    }

    MMDB_free_decode_all(first_member);
}

uint16_t MMDB_open(const char *fname, uint32_t flags, MMDB_s *mmdb)
{
    uint16_t status;

    MMDB_DBG_CARP("MMDB_open %s %d\n", fname, flags);

    return init(mmdb, fname, flags);
}

LOCAL uint16_t init(MMDB_s *mmdb, const char *fname, uint32_t flags)
{
    mmdb->fname = strdup(fname);
    if (mmdb->fname == NULL) {
        return MMDB_OUT_OF_MEMORY;
    }

    int fd = open(fname, O_RDONLY);
    if (fd < 0) {
        return MMDB_FILE_OPEN_ERROR;
    }

    struct stat s;
    fstat(fd, &s);

    if ((flags & MMDB_MODE_MASK) == 0) {
        flags |= MMDB_MODE_STANDARD;
    }
    mmdb->flags = flags;
    ssize_t size;
    mmdb->file_size = size = s.st_size;

    uint8_t *metadata_content = malloc(METADATA_BLOCK_MAX_SIZE);
    assert(metadata_content != NULL);

    if (metadata_content == NULL) {
        return MMDB_INVALID_DATABASE;
    }

    off_t offset = size > METADATA_BLOCK_MAX_SIZE ? METADATA_BLOCK_MAX_SIZE : 0;
    if (MMDB_SUCCESS != int_pread(fd, metadata_content, size, offset)) {
        free(metadata_content);
        return MMDB_IO_ERROR;
    }

    int ok = read_metadata(mmdb, metadata_content, size);
    free(metadata_content);
    if (MMDB_SUCCESS != ok) {
        return ok;
    }

    if (mmdb->metadata.binary_format_major_version != 2) {
        MMDB_close(mmdb);
        return MMDB_UNKNOWN_DATABASE_FORMAT;
    }

    uint8_t *file_content;
    if ((flags & MMDB_MODE_MASK) == MMDB_MODE_MEMORY_CACHE) {
        file_content = malloc(size);
        if (MMDB_SUCCESS != int_pread(fd, file_content, size, 0)) {
            free(file_content);
            return MMDB_IO_ERROR;
        }
    } else {
        file_content =
            (uint8_t *)mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
        if (MAP_FAILED == file_content) {
            return MMDB_IO_ERROR;
        }
    }

    close(fd);

    mmdb->file_in_mem_ptr = file_content;
    mmdb->dataptr =
        file_content + mmdb->metadata.node_count * mmdb->full_record_byte_size;

    return MMDB_SUCCESS;
}

void MMDB_close(MMDB_s *mmdb)
{
    free_all(mmdb);
}

LOCAL void free_all(MMDB_s *mmdb)
{
    if (!mmdb) {
        return;
    }

    if (mmdb->fname) {
        free(mmdb->fname);
    }
    if (mmdb->file_in_mem_ptr) {
        if ((mmdb->flags & MMDB_MODE_MASK) == MMDB_MODE_MEMORY_CACHE) {
            free((void *)mmdb->file_in_mem_ptr);
        } else {
            munmap((void *)mmdb->file_in_mem_ptr, mmdb->file_size);
        }
    }
    if (mmdb->fake_metadata_db) {
        free(mmdb->fake_metadata_db);
    }
    if (mmdb->metadata.database_type) {
        free(mmdb->metadata.database_type);
    }
    if (mmdb->metadata.languages.names) {
        int i;
        for (i = 0; i < mmdb->metadata.languages.count; i++) {
            free((char *)mmdb->metadata.languages.names[i]);
        }
        free(mmdb->metadata.languages.names);
    }
    if (mmdb->metadata.description.descriptions) {
        int i;
        for (i = 0; i < mmdb->metadata.description.count; i++) {
            free((char *)mmdb->metadata.description.descriptions[i]->language);
            free((char *)mmdb->metadata.description.descriptions[i]->
                 description);
            free(mmdb->metadata.description.descriptions[i]);
        }
        free(mmdb->metadata.description.descriptions);
    }
    free((void *)mmdb);
}

int MMDB_get_value(MMDB_entry_s *start, MMDB_return_s *result, ...)
{
    va_list keys;
    va_start(keys, result);
    int ioerror = MMDB_vget_value(start, result, keys);
    va_end(keys);
    return ioerror;
}

int MMDB_vget_value(MMDB_entry_s *start, MMDB_return_s *result, va_list params)
{
    MMDB_decode_s decode, key, value;
    MMDB_s *mmdb = start->mmdb;
    uint32_t offset = start->offset;
    char *src_key;              // = va_arg(params, char *);
    int src_keylen;

    while (src_key = va_arg(params, char *)) {
        MMDB_DBG_CARP("decode_one src_key:%s\n", src_key);
        decode_one(mmdb, offset, &decode);
 donotdecode:
        src_keylen = strlen(src_key);
        switch (decode.data.type) {
        case MMDB_DTYPE_PTR:
            // we follow the pointer
            decode_one(mmdb, decode.data.uinteger, &decode);
            break;

            // learn to skip this
        case MMDB_DTYPE_ARRAY:
            {
                int size = decode.data.data_size;
                int offset = strtol(src_key, NULL, 10);
                if (offset >= size || offset < 0) {
                    result->offset = 0; // not found.
                    goto end;
                }
                for (int i = 0; i < offset; i++) {
                    decode_one(mmdb, decode.offset_to_next, &decode);
                    skip_hash_array(mmdb, &decode);
                }
                if (src_key = va_arg(params, char *)) {
                    decode_one_follow(mmdb, decode.offset_to_next, &decode);
                    offset = decode.offset_to_next;
                    goto donotdecode;
                }
                decode_one_follow(mmdb, decode.offset_to_next, &value);
                memcpy(result, &value.data, sizeof(MMDB_return_s));
                goto end;
            }
            break;
        case MMDB_DTYPE_MAP:
            {
                int size = decode.data.data_size;
                // printf("decode hash with %d keys\n", size);
                offset = decode.offset_to_next;
                while (size-- > 0) {
                    decode_one(mmdb, offset, &key);

                    uint32_t offset_to_value = key.offset_to_next;

                    if (key.data.type == MMDB_DTYPE_PTR) {
                        // while (key.data.type == MMDB_DTYPE_PTR) {
                        decode_one(mmdb, key.data.uinteger, &key);
                        // }
                    }

                    assert(key.data.type == MMDB_DTYPE_BYTES ||
                           key.data.type == MMDB_DTYPE_UTF8_STRING);

                    if (key.data.data_size == src_keylen &&
                        !memcmp(src_key, key.data.ptr, src_keylen)) {
                        if (src_key = va_arg(params, char *)) {
                            // DPRINT_KEY(&key.data);
                            decode_one_follow(mmdb, offset_to_value, &decode);
                            offset = decode.offset_to_next;

                            goto donotdecode;
                        }
                        // found it!
                        decode_one_follow(mmdb, offset_to_value, &value);
                        memcpy(result, &value.data, sizeof(MMDB_return_s));
                        goto end;
                    } else {
                        // we search for another key skip  this
                        decode_one(mmdb, offset_to_value, &value);
                        skip_hash_array(mmdb, &value);
                        offset = value.offset_to_next;
                    }
                }
                // not found!! do something
                //DPRINT_KEY(&key.data);
                //
                result->offset = 0;     // not found.
                goto end;
            }
        default:
            break;
        }
    }
 end:
    va_end(params);
    return MMDB_SUCCESS;
}

// XXX - this is only used in a test file and needs to be moved to the test lib
int MMDB_strcmp_result(MMDB_s *mmdb, MMDB_return_s const *const result,
                       char *str)
{
    if ((mmdb->flags & MMDB_MODE_MASK) == MMDB_MODE_MEMORY_CACHE) {

        if (result->offset > 0) {
            char *str1 = bytesdup(result);
            int ret = strcmp(str1, str);
            if (str1) {
                free(str1);
            }
            return ret;
        }
        return 1;
    }
}

// XXX - only called from MMDB_strcmp_result so can be moved with it
LOCAL char *bytesdup(MMDB_return_s const *const ret)
{
    char *mem = NULL;
    if (ret->offset) {
        mem = malloc(ret->data_size + 1);
        assert(mem != NULL);

        memcpy(mem, ret->ptr, ret->data_size);
        mem[ret->data_size] = '\0';
    }
    return mem;
}

LOCAL void skip_hash_array(MMDB_s *mmdb, MMDB_decode_s *decode)
{
    if (decode->data.type == MMDB_DTYPE_MAP) {
        int size = decode->data.data_size;
        while (size-- > 0) {
            decode_one(mmdb, decode->offset_to_next, decode);   // key
            decode_one(mmdb, decode->offset_to_next, decode);   // value
            skip_hash_array(mmdb, decode);
        }

    } else if (decode->data.type == MMDB_DTYPE_ARRAY) {
        int size = decode->data.data_size;
        while (size-- > 0) {
            decode_one(mmdb, decode->offset_to_next, decode);   // value
            skip_hash_array(mmdb, decode);
        }
    }
}

LOCAL void decode_one_follow(MMDB_s *mmdb, uint32_t offset,
                             MMDB_decode_s *decode)
{
    decode_one(mmdb, offset, decode);
    if (decode->data.type == MMDB_DTYPE_PTR) {
        decode_one(mmdb, decode->data.uinteger, decode);
    }
}

LOCAL void decode_one(MMDB_s *mmdb, uint32_t offset, MMDB_decode_s *decode)
{
    const uint8_t *mem = mmdb->dataptr;
    uint8_t ctrl;
    int type;
    decode->data.offset = offset;
    ctrl = mem[offset++];
    type = (ctrl >> 5) & 7;
    if (type == MMDB_DTYPE_EXT) {
        type = get_ext_type(mem[offset++]);
    }
    // MMDB_DBG_CARP("decode_one type:%d\n", type);

    decode->data.type = type;

    if (type == MMDB_DTYPE_PTR) {
        int psize = (ctrl >> 3) & 3;
        decode->data.uinteger = get_ptr_from(ctrl, &mem[offset], psize);
        decode->data.data_size = psize + 1;
        decode->offset_to_next = offset + psize + 1;
        MMDB_DBG_CARP
            ("decode_one{ptr} ctrl:%d, offset:%d psize:%d point_to:%d\n", ctrl,
             offset, psize, decode->data.uinteger);
        return;
    }

    int size = ctrl & 31;
    switch (size) {
    case 29:
        size = 29 + mem[offset++];
        break;
    case 30:
        size = 285 + get_uint16(&mem[offset]);
        offset += 2;
        break;
    case 31:
        size = 65821 + get_uint24(&mem[offset]);
        offset += 3;
    default:
        break;
    }

    if (type == MMDB_DTYPE_MAP || type == MMDB_DTYPE_ARRAY) {
        decode->data.data_size = size;
        decode->offset_to_next = offset;
        MMDB_DBG_CARP("decode_one type:%d size:%d\n", type, size);
        return;
    }

    if (type == MMDB_DTYPE_BOOLEAN) {
        decode->data.uinteger = size ? 1 : 0;
        decode->data.data_size = 0;
        decode->offset_to_next = offset;
        MMDB_DBG_CARP("decode_one type:%d size:%d\n", type, 0);
        return;
    }

    if (size == 0 && type != MMDB_DTYPE_UINT16 && type != MMDB_DTYPE_UINT32
        && type != MMDB_DTYPE_INT32) {
        decode->data.ptr = NULL;
        decode->data.data_size = 0;
        decode->offset_to_next = offset;
        return;
    }

    if ((type == MMDB_DTYPE_UINT32) || (type == MMDB_DTYPE_UINT16)) {
        decode->data.uinteger = get_uintX(&mem[offset], size);
    } else if (type == MMDB_DTYPE_INT32) {
        decode->data.sinteger = get_sintX(&mem[offset], size);
    } else if (type == MMDB_DTYPE_UINT64) {
        assert(size >= 0 && size <= 8);
        memset(decode->data.c8, 0, 8);
        if (size > 0) {
            memcpy(decode->data.c8 + 8 - size, &mem[offset], size);
        }
    } else if (type == MMDB_DTYPE_UINT128) {
        assert(size >= 0 && size <= 16);
        memset(decode->data.c16, 0, 16);
        if (size > 0) {
            memcpy(decode->data.c16 + 16 - size, &mem[offset], size);
        }
    } else if (type == MMDB_DTYPE_IEEE754_FLOAT) {
        size = 4;
        decode->data.float_value = get_ieee754_float(&mem[offset]);
    } else if (type == MMDB_DTYPE_IEEE754_DOUBLE) {
        size = 8;
        decode->data.double_value = get_ieee754_double(&mem[offset]);
    } else {
        decode->data.ptr = &mem[offset];
        decode->data.data_size = size;
    }
    decode->offset_to_next = offset + size;
    MMDB_DBG_CARP("decode_one type:%d size:%d\n", type, size);

    return;
}

LOCAL int get_ext_type(int raw_ext_type)
{
    return 7 + raw_ext_type;
}

LOCAL void DPRINT_KEY(MMDB_s *mmdb, MMDB_return_s *data)
{
    uint8_t str[256];
    int len = data->data_size > 255 ? 255 : data->data_size;

    memcpy(str, data->ptr, len);

    str[len] = '\0';
    fprintf(stderr, "%s\n", str);
}

LOCAL uint32_t get_ptr_from(uint8_t ctrl, uint8_t const *const ptr,
                            int ptr_size)
{
    uint32_t new_offset;
    switch (ptr_size) {
    case 0:
        new_offset = (ctrl & 7) * 256 + ptr[0];
        break;
    case 1:
        new_offset = 2048 + (ctrl & 7) * 65536 + ptr[0] * 256 + ptr[1];
        break;
    case 2:
        new_offset = 2048 + 524288 + (ctrl & 7) * 16777216 + get_uint24(ptr);
        break;
    case 3:
    default:
        new_offset = get_uint32(ptr);
        break;
    }
    return MMDB_DATASECTION_NOOP_SIZE + new_offset;
}

void MMDB_get_tree(MMDB_entry_s *start, MMDB_decode_all_s **decode_all)
{
    *decode_all = MMDB_alloc_decode_all();
    get_tree(start->mmdb, start->offset, *decode_all);
}

LOCAL void get_tree(MMDB_s *mmdb, uint32_t offset, MMDB_decode_all_s *decode)
{
    decode_one(mmdb, offset, &decode->decode);

    switch (decode->decode.data.type) {
    case MMDB_DTYPE_PTR:
        {
            MMDB_DBG_CARP("Skip ptr\n");
            uint32_t next_offset = decode->decode.offset_to_next;
            uint32_t last_offset;
            while (decode->decode.data.type == MMDB_DTYPE_PTR) {
                decode_one(mmdb, last_offset =
                           decode->decode.data.uinteger, &decode->decode);
            }

            if (decode->decode.data.type == MMDB_DTYPE_ARRAY
                || decode->decode.data.type == MMDB_DTYPE_MAP) {
                get_tree(mmdb, last_offset, decode);
            }
            decode->decode.offset_to_next = next_offset;
        }
        break;
    case MMDB_DTYPE_ARRAY:
        {
            int array_size = decode->decode.data.data_size;
            MMDB_DBG_CARP("Decode array with %d entries\n", array_size);
            uint32_t array_offset = decode->decode.offset_to_next;
            MMDB_decode_all_s *previous = decode;
            // decode->indent = 1;
            while (array_size-- > 0) {
                MMDB_decode_all_s *decode_to = previous->next =
                    MMDB_alloc_decode_all();
                get_tree(mmdb, array_offset, decode_to);
                array_offset = decode_to->decode.offset_to_next;
                while (previous->next) {
                    previous = previous->next;
                }
            }
            decode->decode.offset_to_next = array_offset;

        }
        break;
    case MMDB_DTYPE_MAP:
        {
            int size = decode->decode.data.data_size;

#if MMDB_DEBUG
            int rnd = rand();
            MMDB_DBG_CARP("%u decode hash with %d keys\n", rnd, size);
#endif
            offset = decode->decode.offset_to_next;
            MMDB_decode_all_s *previous = decode;
            while (size-- > 0) {
                MMDB_decode_all_s *decode_to = previous->next =
                    MMDB_alloc_decode_all();
                get_tree(mmdb, offset, decode_to);
                while (previous->next) {
                    previous = previous->next;
                }
#if MMDB_DEBUG
                MMDB_DBG_CARP("key num: %d (%u)", size, rnd);
                DPRINT_KEY(mmdb, &decode_to->decode.data);
#endif

                offset = decode_to->decode.offset_to_next;
                decode_to = previous->next = MMDB_alloc_decode_all();
                get_tree(mmdb, offset, decode_to);
                while (previous->next) {
                    previous = previous->next;
                }
                offset = decode_to->decode.offset_to_next;
            }
            decode->decode.offset_to_next = offset;
        }
        break;
    default:
        break;
    }
}

LOCAL void silly_pindent(int i)
{
    char buffer[1024];
    int size = i >= 1024 ? 1023 : i;
    memset(buffer, 32, size);
    buffer[size] = '\0';
    fputs(buffer, stderr);
}

LOCAL float get_ieee754_float(const uint8_t *restrict p)
{
    volatile float f;
    uint8_t *q = (void *)&f;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    q[3] = p[0];
    q[2] = p[1];
    q[1] = p[2];
    q[0] = p[3];
#else
    memcpy(q, p, 4);
#endif
    return f;
}

LOCAL double get_ieee754_double(const uint8_t *restrict p)
{
    volatile double d;
    uint8_t *q = (void *)&d;

#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    q[7] = p[0];
    q[6] = p[1];
    q[5] = p[2];
    q[4] = p[3];
    q[3] = p[4];
    q[2] = p[5];
    q[1] = p[6];
    q[0] = p[7];
#else
    memcpy(q, p, 8);
#endif

    return d;
}

LOCAL uint32_t get_uint32(const uint8_t *p)
{
    return (p[0] * 16777216U + p[1] * 65536 + p[2] * 256 + p[3]);
}

LOCAL uint32_t get_uint24(const uint8_t *p)
{
    return (p[0] * 65536U + p[1] * 256 + p[2]);
}

LOCAL uint32_t get_uint16(const uint8_t *p)
{
    return (p[0] * 256U + p[1]);
}

LOCAL uint32_t get_uintX(const uint8_t *p, int length)
{
    uint32_t r = 0;
    while (length-- > 0) {
        r <<= 8;
        r += *p++;
    }
    return r;
}

LOCAL int get_sintX(const uint8_t *p, int length)
{
    return (int)get_uintX(p, length);
}

LOCAL int int_pread(int fd, uint8_t *buffer, ssize_t to_read, off_t offset)
{
    while (to_read > 0) {
        ssize_t have_read = pread(fd, buffer, to_read, offset);
        if (have_read <= 0) {
            return MMDB_IO_ERROR;
        }
        to_read -= have_read;
        if (to_read == 0) {
            break;
        }
        offset += have_read;
        buffer += have_read;
    }
    return MMDB_SUCCESS;
}

int MMDB_pread(int fd, uint8_t *buffer, ssize_t to_read, off_t offset)
{
    return int_pread(fd, buffer, to_read, offset);
}

MMDB_decode_all_s *MMDB_alloc_decode_all(void)
{
    MMDB_decode_all_s *decode_all = calloc(1, sizeof(MMDB_decode_all_s));
    assert(decode_all != NULL);

    return decode_all;
}

void MMDB_free_decode_all(MMDB_decode_all_s *freeme)
{
    if (freeme == NULL) {
        return;
    }
    if (freeme->next) {
        MMDB_free_decode_all(freeme->next);
    }
    free(freeme);
}

const char *MMDB_lib_version(void)
{
    return PACKAGE_VERSION;
}

int MMDB_dump(MMDB_s *mmdb, MMDB_decode_all_s *decode_all, int indent)
{
    fprintf(stdout, "Dumping data structure\n");
    while (decode_all) {
        decode_all = dump(mmdb, decode_all, indent);
    }
    // not sure about the return type right now
    return MMDB_SUCCESS;
}

LOCAL MMDB_decode_all_s *dump(MMDB_s *mmdb, MMDB_decode_all_s *decode_all,
                              int indent)
{
    char *string, *bytes;

    switch (decode_all->decode.data.type) {
    case MMDB_DTYPE_MAP:
        {
            int size = decode_all->decode.data.data_size;
            fprintf(stdout, "map with %d pairs\n", size);
            for (decode_all = decode_all->next; size && decode_all; size--) {
                decode_all = dump(mmdb, decode_all, indent + 2);
                decode_all = dump(mmdb, decode_all, indent + 2);
            }
        }
        break;
    case MMDB_DTYPE_ARRAY:
        {
            int size = decode_all->decode.data.data_size;
            fprintf(stdout, "array with %d elements\n", size);
            for (decode_all = decode_all->next; size && decode_all; size--) {
                decode_all = dump(mmdb, decode_all, indent + 2);
            }
        }
        break;
    case MMDB_DTYPE_UTF8_STRING:
        string =
            strndup((char *)decode_all->decode.data.ptr,
                    decode_all->decode.data.data_size);
        silly_pindent(indent);
        fprintf(stdout, "utf8_string = %s\n", string);
        free(string);
        decode_all = decode_all->next;
        break;
    case MMDB_DTYPE_BYTES:
        bytes =
            strndup((char *)decode_all->decode.data.ptr,
                    decode_all->decode.data.data_size);
        silly_pindent(indent);
        fprintf(stdout, "bytes = %s\n", bytes);
        free(bytes);
        decode_all = decode_all->next;
        break;
    case MMDB_DTYPE_IEEE754_DOUBLE:
        silly_pindent(indent);
        fprintf(stdout, "double = %f\n", decode_all->decode.data.double_value);
        decode_all = decode_all->next;
        break;
    case MMDB_DTYPE_IEEE754_FLOAT:
        silly_pindent(indent);
        fprintf(stdout, "float = %f\n", decode_all->decode.data.float_value);
        decode_all = decode_all->next;
        break;
    case MMDB_DTYPE_UINT16:
        silly_pindent(indent);
        fprintf(stdout, "uint16 = %u\n", decode_all->decode.data.uinteger);
        decode_all = decode_all->next;
        break;
    case MMDB_DTYPE_UINT32:
        silly_pindent(indent);
        fprintf(stdout, "uint32 = %u\n", decode_all->decode.data.uinteger);
        decode_all = decode_all->next;
        break;
    case MMDB_DTYPE_BOOLEAN:
        silly_pindent(indent);
        fprintf(stdout, "boolean = %u\n", decode_all->decode.data.uinteger);
        decode_all = decode_all->next;
        break;
    case MMDB_DTYPE_UINT64:
        silly_pindent(indent);
        fprintf(stdout, "uint64 = XXX\n");
        decode_all = decode_all->next;
        break;
    case MMDB_DTYPE_UINT128:
        silly_pindent(indent);
        fprintf(stdout, "uint128 = XXX\n");
        decode_all = decode_all->next;
        break;
    case MMDB_DTYPE_INT32:
        silly_pindent(indent);
        fprintf(stdout, "int32 = %d\n", decode_all->decode.data.sinteger);
        decode_all = decode_all->next;
        break;
    default:
        MMDB_DBG_CARP("unknown type! %d\n", decode_all->decode.data.type);
        assert(0);
    }
    return decode_all;
}
