#include "maxminddb.h"
#include <arpa/inet.h>
#include <assert.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#if HAVE_CONFIG_H
#include <config.h>
#endif

#if MMDB_DEBUG
#define LOCAL
#else
#define LOCAL static
#endif

typedef union {
    struct in_addr v4;
    struct in6_addr v6;
} in_addr_any;

#define MMDB_DATA_SECTION_SEPARATOR (16)

#define METADATA_MARKER "\xab\xcd\xefMaxMind.com"
#define METADATA_BLOCK_MAX_SIZE 20000

/* --prototypes automatically generated by dev-bin/regen-prototypes.pl - don't remove this comment */
LOCAL int resolve_any_address(const char *ipstr, int is_ipv4,
                              in_addr_any *in_addr);
LOCAL int find_address_in_search_tree(MMDB_s *mmdb, uint8_t *address,
                                      MMDB_lookup_result_s *result);
LOCAL uint32_t get_left_28_bit_record(const uint8_t *record);
LOCAL uint32_t get_right_28_bit_record(const uint8_t *record);
LOCAL int read_metadata(MMDB_s *mmdb, uint8_t *metadata_content, ssize_t size);
LOCAL uint32_t value_for_key_as_uint16(MMDB_entry_s *start, char *key);
LOCAL uint32_t value_for_key_as_uint32(MMDB_entry_s *start, char *key);
LOCAL uint64_t value_for_key_as_uint64(MMDB_entry_s *start, char *key);
LOCAL char *value_for_key_as_string(MMDB_entry_s *start, char *key);
LOCAL int populate_languages_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
                                      MMDB_entry_s *metadata_start);
LOCAL int populate_description_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
                                        MMDB_entry_s *metadata_start);
LOCAL uint16_t init(MMDB_s *mmdb, const char *filename, uint32_t flags);
LOCAL void free_mmdb_struct(MMDB_s *mmdb);
LOCAL void free_languages_metadata(MMDB_s *mmdb);
LOCAL void free_descriptions_metadata(MMDB_s *mmdb);
LOCAL int skip_hash_array(MMDB_s *mmdb, MMDB_entry_data_s *entry_data);
LOCAL int decode_one_follow(MMDB_s *mmdb, uint32_t offset,
                            MMDB_entry_data_s *entry_data);
LOCAL int decode_one(MMDB_s *mmdb, uint32_t offset,
                     MMDB_entry_data_s *entry_data);
LOCAL int get_ext_type(int raw_ext_type);
LOCAL void DPRINT_KEY(MMDB_s *mmdb, MMDB_entry_data_s *entry_data);
LOCAL uint32_t get_ptr_from(uint8_t ctrl, uint8_t const *const ptr,
                            int ptr_size);
LOCAL int get_entry_data_list(MMDB_s *mmdb, uint32_t offset,
                              MMDB_entry_data_list_s *entry_data_list);
LOCAL float get_ieee754_float(const uint8_t *restrict p);
LOCAL double get_ieee754_double(const uint8_t *restrict p);
LOCAL uint32_t get_uint32(const uint8_t *p);
LOCAL uint32_t get_uint24(const uint8_t *p);
LOCAL uint32_t get_uint16(const uint8_t *p);
LOCAL uint64_t get_uintX(const uint8_t *p, int length);
LOCAL int32_t get_sintX(const uint8_t *p, int length);
LOCAL int int_pread(int fd, uint8_t *buffer, ssize_t to_read, off_t offset);
LOCAL MMDB_entry_data_list_s *dump(MMDB_entry_data_list_s *entry_data_list,
                                   int indent);
LOCAL void print_indentation(int i);
/* --prototypes end - don't remove this comment-- */

#define CHECKED_DECODE_ONE(mmdb, offset, entry_data)         \
    do {                                                     \
        int status = decode_one(mmdb, offset, entry_data);   \
        if (MMDB_SUCCESS != status) {                        \
            return status;                                   \
        }                                                    \
    } while (0);

#define CHECKED_DECODE_ONE_FOLLOW(mmdb, offset, entry_data)       \
    do {                                                          \
        int status = decode_one_follow(mmdb, offset, entry_data); \
        if (MMDB_SUCCESS != status) {                             \
            return status;                                        \
        }                                                         \
    } while (0);

#if !defined HAVE_MEMMEM
LOCAL void *memmem(const void *big, size_t big_len, const void *little,
                   size_t little_len)
{
    if (little_len) {
        int first_char = ((uint8_t *)little)[0];
        const void *ptr = big;
        size_t len = big_len;
        while (len >= little_len
               && (ptr = memchr(ptr, first_char, len - little_len + 1))) {
            if (!memcmp(ptr, little, little_len)) {
                return (void *)ptr;
            }
            len = big_len - (++ptr - big);
        }
    }
    return NULL;
}
#endif

MMDB_lookup_result_s *MMDB_lookup(MMDB_s *mmdb, const char *ipstr,
                                  int *gai_error, int *mmdb_error)
{
    int is_ipv4 = mmdb->metadata.ip_version == 4 ? 1 : 0;
    in_addr_any in_addr;

    *gai_error = resolve_any_address(ipstr, is_ipv4, &in_addr);

    if (*gai_error) {
        return NULL;
    }

    MMDB_lookup_result_s *result = malloc(sizeof(MMDB_lookup_result_s));
    if (NULL == result) {
        *mmdb_error = MMDB_OUT_OF_MEMORY;
        return NULL;
    }

    result->entry.mmdb = mmdb;

    uint8_t *address;
    if (is_ipv4) {
        address = (uint8_t *)&in_addr.v4.s_addr;
    } else {
        address = (uint8_t *)&in_addr.v6;
    }

    *mmdb_error = find_address_in_search_tree(mmdb, address, result);

    if (*mmdb_error) {
        free(result);
        return NULL;
    }

    if (result->entry.offset > 0) {
        return result;
    } else {
        free(result);
        return NULL;
    }
}

LOCAL int resolve_any_address(const char *ipstr, int is_ipv4,
                              in_addr_any *in_addr)
{
    int ai_flags = AI_NUMERICHOST;
    struct addrinfo hints = {
        .ai_socktype = SOCK_STREAM
    };
    struct addrinfo *addresses;
    int gai_status;

    if (is_ipv4) {
        hints.ai_flags = ai_flags;
        hints.ai_family = AF_INET;
    } else {
        hints.ai_flags = ai_flags | AI_V4MAPPED;
        hints.ai_family = AF_INET6;
    }

    gai_status = getaddrinfo(ipstr, NULL, &hints, &addresses);
    if (gai_status) {
        return gai_status;
    }

    if (hints.ai_family == AF_INET) {
        memcpy(&((struct in_addr *)in_addr)->s_addr,
               &((struct sockaddr_in *)addresses->ai_addr)->sin_addr.s_addr, 4);
    } else if (hints.ai_family == AF_INET6) {
        memcpy(&((struct in6_addr *)in_addr)->s6_addr,
               ((struct sockaddr_in6 *)addresses->ai_addr)->sin6_addr.s6_addr,
               16);
    } else {
        /* This should never happen */
        assert(0);
    }

    freeaddrinfo(addresses);

    return 0;
}

LOCAL int find_address_in_search_tree(MMDB_s *mmdb, uint8_t *address,
                                      MMDB_lookup_result_s *result)
{
    uint32_t node_count = mmdb->metadata.node_count;
    uint16_t record_length = mmdb->full_record_byte_size;
    const uint8_t *search_tree = mmdb->file_content;
    const uint8_t *record_pointer;
    uint16_t max_depth0 = mmdb->depth - 1;
    uint32_t value = 0;

    uint32_t (*left_record_value) (const uint8_t *);
    uint32_t (*right_record_value) (const uint8_t *);
    uint8_t right_record_offset;

    if (record_length == 6) {
        left_record_value = &get_uint24;
        right_record_value = &get_uint24;
        right_record_offset = 3;
    } else if (record_length == 7) {
        left_record_value = &get_left_28_bit_record;
        right_record_value = &get_right_28_bit_record;
        right_record_offset = 3;
    } else if (record_length == 8) {
        left_record_value = &get_uint32;
        right_record_value = &get_uint32;
        right_record_offset = 4;
    }

    for (uint16_t current_bit = max_depth0; current_bit >= 0; current_bit--) {
        record_pointer = &search_tree[value * record_length];
        if (address[(max_depth0 - current_bit) >> 3] &
            (1U << (~(max_depth0 - current_bit) & 7))) {

            record_pointer += right_record_offset;
            value = right_record_value(record_pointer);
        } else {
            value = left_record_value(record_pointer);
        }

        if (value >= node_count) {
            result->netmask = mmdb->depth - current_bit;
            result->entry.offset = value - node_count;
            return MMDB_SUCCESS;
        }
    }

    // We should not be able to reach this return. If we do, something very bad happened.
    return MMDB_CORRUPT_DATABASE;
}

LOCAL uint32_t get_left_28_bit_record(const uint8_t *record)
{
    return record[0] * 65536 + record[1] * 256 + record[2] +
        ((record[3] & 0xf0) << 20);
}

LOCAL uint32_t get_right_28_bit_record(const uint8_t *record)
{
    uint32_t value = get_uint32(record);
    return value & 0xfffffff;
}

LOCAL int read_metadata(MMDB_s *mmdb, uint8_t *metadata_content, ssize_t size)
{
    const uint8_t *metadata = memmem(metadata_content, size, METADATA_MARKER,
                                     strlen(METADATA_MARKER));
    if (NULL == metadata) {
        return MMDB_INVALID_DATABASE;
    }

    /* We need to create a fake MMDB_s struct in order to decode values from
       the metadata. The metadata is basically just like the data section, so we
       want to use the same functions we use for the data section to get metadata
       values. */
    MMDB_s metadata_db;
    metadata_db.data_section = metadata + strlen(METADATA_MARKER);

    MMDB_entry_s metadata_start;
    metadata_start.mmdb = &metadata_db;
    metadata_start.offset = 0;

    mmdb->metadata.node_count =
        value_for_key_as_uint32(&metadata_start, "node_count");

    mmdb->metadata.record_size =
        value_for_key_as_uint16(&metadata_start, "record_size");

    if (mmdb->metadata.record_size != 24 && mmdb->metadata.record_size != 28
        && mmdb->metadata.record_size != 32) {
        return MMDB_UNKNOWN_DATABASE_FORMAT;
    }

    mmdb->metadata.ip_version =
        value_for_key_as_uint16(&metadata_start, "ip_version");

    mmdb->metadata.database_type =
        value_for_key_as_string(&metadata_start, "database_type");

    int status =
        populate_languages_metadata(mmdb, &metadata_db, &metadata_start);
    if (MMDB_SUCCESS != status) {
        return status;
    }

    mmdb->metadata.binary_format_major_version =
        value_for_key_as_uint16(&metadata_start, "binary_format_major_version");

    mmdb->metadata.binary_format_minor_version =
        value_for_key_as_uint16(&metadata_start, "binary_format_minor_version");

    mmdb->metadata.build_epoch =
        value_for_key_as_uint64(&metadata_start, "build_epoch");

    status = populate_description_metadata(mmdb, &metadata_db, &metadata_start);
    if (MMDB_SUCCESS != status) {
        return status;
    }

    mmdb->full_record_byte_size = mmdb->metadata.record_size * 2 / 8U;

    mmdb->depth = mmdb->metadata.ip_version == 4 ? 32 : 128;

    return MMDB_SUCCESS;
}

LOCAL uint32_t value_for_key_as_uint16(MMDB_entry_s *start, char *key)
{
    MMDB_entry_data_s entry_data;
    MMDB_get_value(start, &entry_data, key, NULL);
    return entry_data.uint16;
}

LOCAL uint32_t value_for_key_as_uint32(MMDB_entry_s *start, char *key)
{
    MMDB_entry_data_s entry_data;
    MMDB_get_value(start, &entry_data, key, NULL);
    return entry_data.uint32;
}

LOCAL uint64_t value_for_key_as_uint64(MMDB_entry_s *start, char *key)
{
    MMDB_entry_data_s entry_data;
    MMDB_get_value(start, &entry_data, key, NULL);
    return entry_data.uint64;
}

LOCAL char *value_for_key_as_string(MMDB_entry_s *start, char *key)
{
    MMDB_entry_data_s entry_data;
    MMDB_get_value(start, &entry_data, key, NULL);
    return strndup((char *)entry_data.utf8_string, entry_data.data_size);
}

LOCAL int populate_languages_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
                                      MMDB_entry_s *metadata_start)
{
    MMDB_entry_data_s entry_data;
    MMDB_entry_s array_start;
    size_t array_size;
    MMDB_entry_data_list_s *member;
    MMDB_entry_data_list_s *first_member;

    MMDB_get_value(metadata_start, &entry_data, "languages", NULL);

    if (MMDB_DTYPE_ARRAY != entry_data.type) {
        return MMDB_INVALID_DATABASE;
    }

    array_start.mmdb = metadata_db;
    array_start.offset = entry_data.offset;

    MMDB_get_entry_data_list(&array_start, &member);

    first_member = member;

    array_size = member->entry_data.data_size;
    mmdb->metadata.languages.count = 0;
    mmdb->metadata.languages.names = malloc(array_size * sizeof(char *));
    if (NULL == mmdb->metadata.languages.names) {
        return MMDB_OUT_OF_MEMORY;
    }

    for (int i = 0; i < array_size; i++) {
        member = member->next;
        if (MMDB_DTYPE_UTF8_STRING != member->entry_data.type) {
            return MMDB_INVALID_DATABASE;
        }

        mmdb->metadata.languages.names[i] =
            strndup((char *)member->entry_data.utf8_string,
                    member->entry_data.data_size);

        if (NULL == mmdb->metadata.languages.names[i]) {
            return MMDB_OUT_OF_MEMORY;
        }
        // We assign this as we go so that if we fail a malloc and need to
        // free it, the count is right.
        mmdb->metadata.languages.count = i + 1;
    }

    MMDB_free_entry_data_list(first_member);

    return MMDB_SUCCESS;
}

LOCAL int populate_description_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
                                        MMDB_entry_s *metadata_start)
{
    MMDB_entry_data_s entry_data;
    MMDB_entry_s map_start;
    size_t map_size;
    MMDB_entry_data_list_s *member;
    MMDB_entry_data_list_s *first_member;
    int i;

    MMDB_get_value(metadata_start, &entry_data, "description", NULL);

    if (MMDB_DTYPE_MAP != entry_data.type) {
        return MMDB_INVALID_DATABASE;
    }

    map_start.mmdb = metadata_db;
    map_start.offset = entry_data.offset;

    MMDB_get_entry_data_list(&map_start, &member);

    first_member = member;

    map_size = member->entry_data.data_size;
    mmdb->metadata.description.count = 0;
    mmdb->metadata.description.descriptions =
        malloc(map_size * sizeof(MMDB_description_s *));
    if (NULL == mmdb->metadata.description.descriptions) {
        return MMDB_OUT_OF_MEMORY;
    }

    for (i = 0; i < map_size; i++) {
        mmdb->metadata.description.descriptions[i] =
            malloc(sizeof(MMDB_description_s));
        if (NULL == mmdb->metadata.description.descriptions[i]) {
            return MMDB_OUT_OF_MEMORY;
        }

        mmdb->metadata.description.count = i + 1;
        mmdb->metadata.description.descriptions[i]->language = NULL;
        mmdb->metadata.description.descriptions[i]->description = NULL;

        member = member->next;

        if (MMDB_DTYPE_UTF8_STRING != member->entry_data.type) {
            return MMDB_INVALID_DATABASE;
        }

        mmdb->metadata.description.descriptions[i]->language =
            strndup((char *)member->entry_data.utf8_string,
                    member->entry_data.data_size);

        if (NULL == mmdb->metadata.description.descriptions[i]->language) {
            return MMDB_OUT_OF_MEMORY;
        }

        member = member->next;

        if (MMDB_DTYPE_UTF8_STRING != member->entry_data.type) {
            return MMDB_INVALID_DATABASE;
        }

        mmdb->metadata.description.descriptions[i]->description =
            strndup((char *)member->entry_data.utf8_string,
                    member->entry_data.data_size);

        if (NULL == mmdb->metadata.description.descriptions[i]->description) {
            return MMDB_OUT_OF_MEMORY;
        }
    }

    MMDB_free_entry_data_list(first_member);

    return MMDB_SUCCESS;
}

uint16_t MMDB_open(const char *filename, uint32_t flags, MMDB_s *mmdb)
{
    uint16_t status;

    MMDB_DBG_CARP("MMDB_open %s %d\n", filename, flags);

    return init(mmdb, filename, flags);
}

LOCAL uint16_t init(MMDB_s *mmdb, const char *filename, uint32_t flags)
{
    mmdb->filename = NULL;
    mmdb->file_content = NULL;
    mmdb->data_section = NULL;

    mmdb->filename = strdup(filename);
    if (mmdb->filename == NULL) {
        free_mmdb_struct(mmdb);
        return MMDB_OUT_OF_MEMORY;
    }

    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        free_mmdb_struct(mmdb);
        return MMDB_FILE_OPEN_ERROR;
    }

    struct stat s;
    fstat(fd, &s);

    if ((flags & MMDB_MODE_MASK) == 0) {
        flags |= MMDB_MODE_MMAP;
    }
    mmdb->flags = flags;
    ssize_t size;
    mmdb->file_size = size = s.st_size;

    uint8_t *metadata_content = malloc(METADATA_BLOCK_MAX_SIZE);
    if (NULL == metadata_content) {
        free_mmdb_struct(mmdb);
        return MMDB_OUT_OF_MEMORY;
    }

    off_t offset = size > METADATA_BLOCK_MAX_SIZE ? METADATA_BLOCK_MAX_SIZE : 0;
    if (MMDB_SUCCESS != int_pread(fd, metadata_content, size, offset)) {
        free_mmdb_struct(mmdb);
        return MMDB_IO_ERROR;
    }

    int ok = read_metadata(mmdb, metadata_content, size);
    free(metadata_content);
    if (MMDB_SUCCESS != ok) {
        free_mmdb_struct(mmdb);
        return ok;
    }

    if (mmdb->metadata.binary_format_major_version != 2) {
        free_mmdb_struct(mmdb);
        return MMDB_UNKNOWN_DATABASE_FORMAT;
    }

    uint8_t *file_content;
    if ((flags & MMDB_MODE_MASK) == MMDB_MODE_MEMORY_CACHE) {
        file_content = malloc(size);
        if (NULL == file_content) {
            free_mmdb_struct(mmdb);
            return MMDB_OUT_OF_MEMORY;
        }
        if (MMDB_SUCCESS != int_pread(fd, file_content, size, 0)) {
            free_mmdb_struct(mmdb);
            return MMDB_IO_ERROR;
        }
    } else {
        file_content =
            (uint8_t *)mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
        if (MAP_FAILED == file_content) {
            free_mmdb_struct(mmdb);
            return MMDB_IO_ERROR;
        }
    }

    close(fd);

    mmdb->file_content = file_content;
    mmdb->data_section =
        file_content + mmdb->metadata.node_count * mmdb->full_record_byte_size;

    return MMDB_SUCCESS;
}

void MMDB_close(MMDB_s *mmdb)
{
    free_mmdb_struct(mmdb);
}

LOCAL void free_mmdb_struct(MMDB_s *mmdb)
{
    if (!mmdb) {
        return;
    }

    if (NULL != mmdb->filename) {
        free(mmdb->filename);
    }
    if (NULL != mmdb->file_content) {
        if ((mmdb->flags & MMDB_MODE_MASK) == MMDB_MODE_MEMORY_CACHE) {
            free((void *)mmdb->file_content);
        } else {
            munmap((void *)mmdb->file_content, mmdb->file_size);
        }
    }

    if (NULL != mmdb->metadata.database_type) {
        free(mmdb->metadata.database_type);
    }

    free_languages_metadata(mmdb);
    free_descriptions_metadata(mmdb);
    free((void *)mmdb);
}

LOCAL void free_languages_metadata(MMDB_s *mmdb)
{
    if (!mmdb->metadata.languages.count) {
        return;
    }

    for (int i = 0; i < mmdb->metadata.languages.count; i++) {
        free((char *)mmdb->metadata.languages.names[i]);
    }
    free(mmdb->metadata.languages.names);
}

LOCAL void free_descriptions_metadata(MMDB_s *mmdb)
{
    if (!mmdb->metadata.description.count) {
        return;
    }

    for (size_t i = 0; i < mmdb->metadata.description.count; i++) {
        if (NULL != mmdb->metadata.description.descriptions[i]) {
            if (NULL != mmdb->metadata.description.descriptions[i]->language) {
                free((char *)mmdb->metadata.description.descriptions[i]->
                     language);
            }

            if (NULL != mmdb->metadata.description.descriptions[i]->description) {
                free((char *)mmdb->metadata.description.
                     descriptions[i]->description);
            }
            free(mmdb->metadata.description.descriptions[i]);
        }
    }

    free(mmdb->metadata.description.descriptions);
}

int MMDB_get_value(MMDB_entry_s *start, MMDB_entry_data_s *entry_data, ...)
{
    va_list keys;
    va_start(keys, entry_data);
    int status = MMDB_vget_value(start, entry_data, keys);
    va_end(keys);
    return status;
}

int MMDB_vget_value(MMDB_entry_s *start, MMDB_entry_data_s *entry_data,
                    va_list params)
{
    MMDB_entry_data_s key, value;
    MMDB_s *mmdb = start->mmdb;
    uint32_t offset = start->offset;
    char *src_key;
    int src_keylen;

    memset(entry_data, 0, sizeof(MMDB_entry_data_s));

    do {
        CHECKED_DECODE_ONE(mmdb, offset, entry_data);

        src_key = va_arg(params, char *);
        MMDB_DBG_CARP("decode_one src_key:%s\n", src_key);

        if (NULL == src_key) {
            goto end;
        }

 one_key:
        src_keylen = strlen(src_key);
        switch (entry_data->type) {
        case MMDB_DTYPE_PTR:
            CHECKED_DECODE_ONE(mmdb, entry_data->pointer, entry_data);
            break;

            /* XXX - it'd be good to find a quicker way to skip through these
               entries that doesn't involve decoding them
               completely. Basically we need to just use the size from the
               control byte to advance our pointer rather than calling
               decode_one(). */
        case MMDB_DTYPE_ARRAY:
            {
                int size = entry_data->data_size;
                int offset = strtol(src_key, NULL, 10);
                if (offset >= size || offset < 0) {
                    entry_data->offset = 0;
                    goto end;
                }
                for (int i = 0; i < offset; i++) {
                    CHECKED_DECODE_ONE(mmdb, entry_data->offset_to_next,
                                       entry_data);
                    int status = skip_hash_array(mmdb, entry_data);
                    if (MMDB_SUCCESS != status) {
                        return status;
                    }
                }
                if (src_key = va_arg(params, char *)) {
                    CHECKED_DECODE_ONE_FOLLOW(mmdb, entry_data->offset_to_next,
                                              entry_data);
                    offset = entry_data->offset_to_next;
                    goto one_key;
                }
                CHECKED_DECODE_ONE_FOLLOW(mmdb, entry_data->offset_to_next,
                                          &value);
                memcpy(entry_data, &value, sizeof(MMDB_entry_data_s));
                goto end;
            }
            break;
        case MMDB_DTYPE_MAP:
            {
                int size = entry_data->data_size;
                offset = entry_data->offset_to_next;
                while (size-- > 0) {
                    CHECKED_DECODE_ONE(mmdb, offset, &key);

                    uint32_t offset_to_value = key.offset_to_next;

                    if (key.type == MMDB_DTYPE_PTR) {
                        CHECKED_DECODE_ONE(mmdb, key.pointer, &key);
                    }

                    if (MMDB_DTYPE_UTF8_STRING != key.type) {
                        return MMDB_INVALID_DATA;
                    }

                    if (key.data_size == src_keylen &&
                        !memcmp(src_key, key.utf8_string, src_keylen)) {

                        if (src_key = va_arg(params, char *)) {
                            CHECKED_DECODE_ONE_FOLLOW(mmdb, offset_to_value,
                                                      entry_data);
                            offset = entry_data->offset_to_next;

                            goto one_key;
                        }
                        CHECKED_DECODE_ONE_FOLLOW(mmdb, offset_to_value,
                                                  &value);
                        memcpy(entry_data, &value, sizeof(MMDB_entry_data_s));
                        goto end;
                    } else {
                        CHECKED_DECODE_ONE(mmdb, offset_to_value, &value);
                        int status = skip_hash_array(mmdb, &value);
                        if (MMDB_SUCCESS != status) {
                            return status;
                        }
                        offset = value.offset_to_next;
                    }
                }

                entry_data->offset = 0;
                goto end;
            }
        default:
            break;
        }
    }
    while (src_key);

 end:
    va_end(params);
    return MMDB_SUCCESS;
}

LOCAL int skip_hash_array(MMDB_s *mmdb, MMDB_entry_data_s *entry_data)
{
    if (entry_data->type == MMDB_DTYPE_MAP) {
        int size = entry_data->data_size;
        while (size-- > 0) {
            CHECKED_DECODE_ONE(mmdb, entry_data->offset_to_next, entry_data);   // key
            CHECKED_DECODE_ONE(mmdb, entry_data->offset_to_next, entry_data);   // value
            skip_hash_array(mmdb, entry_data);
        }

    } else if (entry_data->type == MMDB_DTYPE_ARRAY) {
        int size = entry_data->data_size;
        while (size-- > 0) {
            CHECKED_DECODE_ONE(mmdb, entry_data->offset_to_next, entry_data);   // value
            skip_hash_array(mmdb, entry_data);
        }
    }

    return MMDB_SUCCESS;
}

LOCAL int decode_one_follow(MMDB_s *mmdb, uint32_t offset,
                            MMDB_entry_data_s *entry_data)
{
    CHECKED_DECODE_ONE(mmdb, offset, entry_data);
    if (entry_data->type == MMDB_DTYPE_PTR) {
        CHECKED_DECODE_ONE(mmdb, entry_data->pointer, entry_data);
    }
}

LOCAL int decode_one(MMDB_s *mmdb, uint32_t offset,
                     MMDB_entry_data_s *entry_data)
{
    const uint8_t *mem = mmdb->data_section;
    uint8_t ctrl;
    int type;

    entry_data->offset = offset;
    ctrl = mem[offset++];
    type = (ctrl >> 5) & 7;
    if (type == MMDB_DTYPE_EXT) {
        type = get_ext_type(mem[offset++]);
    }

    entry_data->type = type;

    if (type == MMDB_DTYPE_PTR) {
        int psize = (ctrl >> 3) & 3;
        entry_data->pointer = get_ptr_from(ctrl, &mem[offset], psize);
        entry_data->data_size = psize + 1;
        entry_data->offset_to_next = offset + psize + 1;
        MMDB_DBG_CARP
            ("decode_one{ptr} ctrl:%d, offset:%d psize:%d point_to:%d\n", ctrl,
             offset, psize, entry_data->pointer);
        return MMDB_SUCCESS;
    }

    int size = ctrl & 31;
    switch (size) {
    case 29:
        size = 29 + mem[offset++];
        break;
    case 30:
        size = 285 + get_uint16(&mem[offset]);
        offset += 2;
        break;
    case 31:
        size = 65821 + get_uint24(&mem[offset]);
        offset += 3;
    default:
        break;
    }

    if (type == MMDB_DTYPE_MAP || type == MMDB_DTYPE_ARRAY) {
        entry_data->data_size = size;
        entry_data->offset_to_next = offset;
        MMDB_DBG_CARP("decode_one type:%d size:%d\n", type, size);
        return MMDB_SUCCESS;
    }

    if (type == MMDB_DTYPE_BOOLEAN) {
        entry_data->boolean = size ? true : false;
        entry_data->data_size = 0;
        entry_data->offset_to_next = offset;
        MMDB_DBG_CARP("decode_one type:%d size:%d\n", type, 0);
        return MMDB_SUCCESS;
    }

    if (size == 0 && type != MMDB_DTYPE_UINT16 && type != MMDB_DTYPE_UINT32
        && type != MMDB_DTYPE_INT32) {
        entry_data->bytes = NULL;
        entry_data->utf8_string = NULL;
        entry_data->data_size = 0;
        entry_data->offset_to_next = offset;
        return MMDB_SUCCESS;
    }

    if (type == MMDB_DTYPE_UINT16) {
        if (size < 0 || size > 2) {
            return MMDB_INVALID_DATA;
        }
        entry_data->uint16 = (uint16_t)get_uintX(&mem[offset], size);
    } else if (type == MMDB_DTYPE_UINT32) {
        if (size < 0 || size > 4) {
            return MMDB_INVALID_DATA;
        }
        entry_data->uint32 = (uint32_t)get_uintX(&mem[offset], size);
    } else if (type == MMDB_DTYPE_INT32) {
        if (size < 0 || size > 4) {
            return MMDB_INVALID_DATA;
        }
        entry_data->int32 = get_sintX(&mem[offset], size);
    } else if (type == MMDB_DTYPE_UINT64) {
        if (size < 0 || size > 8) {
            return MMDB_INVALID_DATA;
        }
        entry_data->uint64 = get_uintX(&mem[offset], size);
    } else if (type == MMDB_DTYPE_UINT128) {
        if (size < 0 || size > 16) {
            return MMDB_INVALID_DATA;
        }

        memset(entry_data->uint128, 0, 16);
        if (size > 0) {
            memcpy(entry_data->uint128 + 16 - size, &mem[offset], size);
        }
    } else if (type == MMDB_DTYPE_FLOAT) {
        size = 4;
        entry_data->float_value = get_ieee754_float(&mem[offset]);
    } else if (type == MMDB_DTYPE_DOUBLE) {
        size = 8;
        entry_data->double_value = get_ieee754_double(&mem[offset]);
    } else if (type == MMDB_DTYPE_UTF8_STRING) {
        entry_data->utf8_string = &mem[offset];
        entry_data->data_size = size;
    } else if (type == MMDB_DTYPE_BYTES) {
        entry_data->bytes = &mem[offset];
        entry_data->data_size = size;
    }
    entry_data->offset_to_next = offset + size;
    MMDB_DBG_CARP("decode_one type:%d size:%d\n", type, size);

    return MMDB_SUCCESS;
}

LOCAL int get_ext_type(int raw_ext_type)
{
    return 7 + raw_ext_type;
}

LOCAL void DPRINT_KEY(MMDB_s *mmdb, MMDB_entry_data_s *entry_data)
{
    uint8_t str[256];
    int len = entry_data->data_size > 255 ? 255 : entry_data->data_size;

    memcpy(str, entry_data->utf8_string, len);

    str[len] = '\0';
    fprintf(stderr, "%s\n", str);
}

LOCAL uint32_t get_ptr_from(uint8_t ctrl, uint8_t const *const ptr,
                            int ptr_size)
{
    uint32_t new_offset;
    switch (ptr_size) {
    case 0:
        new_offset = (ctrl & 7) * 256 + ptr[0];
        break;
    case 1:
        new_offset = 2048 + (ctrl & 7) * 65536 + ptr[0] * 256 + ptr[1];
        break;
    case 2:
        new_offset = 2048 + 524288 + (ctrl & 7) * 16777216 + get_uint24(ptr);
        break;
    case 3:
    default:
        new_offset = get_uint32(ptr);
        break;
    }
    return MMDB_DATA_SECTION_SEPARATOR + new_offset;
}

int MMDB_get_entry_data_list(MMDB_entry_s *start,
                             MMDB_entry_data_list_s **entry_data_list)
{
    *entry_data_list = MMDB_alloc_entry_data_list();
    if (NULL == &entry_data_list) {
        return MMDB_OUT_OF_MEMORY;
    }
    return get_entry_data_list(start->mmdb, start->offset, *entry_data_list);
}

LOCAL int get_entry_data_list(MMDB_s *mmdb, uint32_t offset,
                              MMDB_entry_data_list_s *entry_data_list)
{
    CHECKED_DECODE_ONE(mmdb, offset, &entry_data_list->entry_data);

    switch (entry_data_list->entry_data.type) {
    case MMDB_DTYPE_PTR:
        {
            MMDB_DBG_CARP("Skip ptr\n");
            uint32_t next_offset = entry_data_list->entry_data.offset_to_next;
            uint32_t last_offset;
            while (entry_data_list->entry_data.type == MMDB_DTYPE_PTR) {
                CHECKED_DECODE_ONE(mmdb, last_offset =
                                   entry_data_list->entry_data.pointer,
                                   &entry_data_list->entry_data);
            }

            if (entry_data_list->entry_data.type == MMDB_DTYPE_ARRAY
                || entry_data_list->entry_data.type == MMDB_DTYPE_MAP) {

                int status =
                    get_entry_data_list(mmdb, last_offset, entry_data_list);
                if (MMDB_SUCCESS != status) {
                    return status;
                }
            }
            entry_data_list->entry_data.offset_to_next = next_offset;
        }
        break;
    case MMDB_DTYPE_ARRAY:
        {
            int array_size = entry_data_list->entry_data.data_size;
            MMDB_DBG_CARP("Decode array with %d entries\n", array_size);
            uint32_t array_offset = entry_data_list->entry_data.offset_to_next;
            MMDB_entry_data_list_s *previous = entry_data_list;
            while (array_size-- > 0) {
                MMDB_entry_data_list_s *entry_data_list_to = previous->next =
                    MMDB_alloc_entry_data_list();
                if (NULL == entry_data_list_to) {
                    return MMDB_OUT_OF_MEMORY;
                }

                int status =
                    get_entry_data_list(mmdb, array_offset, entry_data_list_to);
                if (MMDB_SUCCESS != status) {
                    return status;
                }

                array_offset = entry_data_list_to->entry_data.offset_to_next;
                while (previous->next) {
                    previous = previous->next;
                }
            }
            entry_data_list->entry_data.offset_to_next = array_offset;

        }
        break;
    case MMDB_DTYPE_MAP:
        {
            int size = entry_data_list->entry_data.data_size;

#if MMDB_DEBUG
            int rnd = rand();
            MMDB_DBG_CARP("%u decode hash with %d keys\n", rnd, size);
#endif
            offset = entry_data_list->entry_data.offset_to_next;
            MMDB_entry_data_list_s *previous = entry_data_list;
            while (size-- > 0) {
                MMDB_entry_data_list_s *entry_data_list_to = previous->next =
                    MMDB_alloc_entry_data_list();
                if (NULL == entry_data_list_to) {
                    return MMDB_OUT_OF_MEMORY;
                }

                int status =
                    get_entry_data_list(mmdb, offset, entry_data_list_to);
                if (MMDB_SUCCESS != status) {
                    return status;
                }

                while (previous->next) {
                    previous = previous->next;
                }
#if MMDB_DEBUG
                MMDB_DBG_CARP("key num: %d (%u)", size, rnd);
                DPRINT_KEY(mmdb, &entry_data_list_to->entry_data);
#endif

                offset = entry_data_list_to->entry_data.offset_to_next;
                entry_data_list_to = previous->next =
                    MMDB_alloc_entry_data_list();

                if (NULL == entry_data_list_to) {
                    return MMDB_OUT_OF_MEMORY;
                }

                status = get_entry_data_list(mmdb, offset, entry_data_list_to);
                if (MMDB_SUCCESS != status) {
                    return status;
                }

                while (previous->next) {
                    previous = previous->next;
                }
                offset = entry_data_list_to->entry_data.offset_to_next;
            }
            entry_data_list->entry_data.offset_to_next = offset;
        }
        break;
    default:
        break;
    }

    return MMDB_SUCCESS;
}

LOCAL float get_ieee754_float(const uint8_t *restrict p)
{
    volatile float f;
    uint8_t *q = (void *)&f;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    q[3] = p[0];
    q[2] = p[1];
    q[1] = p[2];
    q[0] = p[3];
#else
    memcpy(q, p, 4);
#endif
    return f;
}

LOCAL double get_ieee754_double(const uint8_t *restrict p)
{
    volatile double d;
    uint8_t *q = (void *)&d;

#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    q[7] = p[0];
    q[6] = p[1];
    q[5] = p[2];
    q[4] = p[3];
    q[3] = p[4];
    q[2] = p[5];
    q[1] = p[6];
    q[0] = p[7];
#else
    memcpy(q, p, 8);
#endif

    return d;
}

LOCAL uint32_t get_uint32(const uint8_t *p)
{
    return (p[0] * 16777216U + p[1] * 65536 + p[2] * 256 + p[3]);
}

LOCAL uint32_t get_uint24(const uint8_t *p)
{
    return (p[0] * 65536U + p[1] * 256 + p[2]);
}

LOCAL uint32_t get_uint16(const uint8_t *p)
{
    return (p[0] * 256U + p[1]);
}

LOCAL uint64_t get_uintX(const uint8_t *p, int length)
{
    uint64_t value = 0;
    while (length-- > 0) {
        value <<= 8;
        value += *p++;
    }
    return value;
}

LOCAL int32_t get_sintX(const uint8_t *p, int length)
{
    return (int32_t)get_uintX(p, length);
}

LOCAL int int_pread(int fd, uint8_t *buffer, ssize_t to_read, off_t offset)
{
    while (to_read > 0) {
        ssize_t have_read = pread(fd, buffer, to_read, offset);
        if (have_read <= 0) {
            return MMDB_IO_ERROR;
        }
        to_read -= have_read;
        if (to_read == 0) {
            break;
        }
        offset += have_read;
        buffer += have_read;
    }
    return MMDB_SUCCESS;
}

MMDB_entry_data_list_s *MMDB_alloc_entry_data_list(void)
{
    return calloc(1, sizeof(MMDB_entry_data_list_s));
}

void MMDB_free_entry_data_list(MMDB_entry_data_list_s *freeme)
{
    if (freeme == NULL) {
        return;
    }
    if (freeme->next) {
        MMDB_free_entry_data_list(freeme->next);
    }
    free(freeme);
}

const char *MMDB_lib_version(void)
{
    return PACKAGE_VERSION;
}

int MMDB_dump(MMDB_entry_data_list_s *entry_data_list, int indent)
{
    fprintf(stdout, "Dumping data structure\n");
    while (entry_data_list) {
        entry_data_list = dump(entry_data_list, indent);
    }

    return MMDB_SUCCESS;
}

LOCAL MMDB_entry_data_list_s *dump(MMDB_entry_data_list_s *entry_data_list,
                                   int indent)
{
    char *string, *bytes;

    switch (entry_data_list->entry_data.type) {
    case MMDB_DTYPE_MAP:
        {
            int size = entry_data_list->entry_data.data_size;
            fprintf(stdout, "map with %d pairs\n", size);
            for (entry_data_list = entry_data_list->next;
                 size && entry_data_list; size--) {
                entry_data_list = dump(entry_data_list, indent + 2);
                entry_data_list = dump(entry_data_list, indent + 2);
            }
        }
        break;
    case MMDB_DTYPE_ARRAY:
        {
            int size = entry_data_list->entry_data.data_size;
            fprintf(stdout, "array with %d elements\n", size);
            for (entry_data_list = entry_data_list->next;
                 size && entry_data_list; size--) {
                entry_data_list = dump(entry_data_list, indent + 2);
            }
        }
        break;
    case MMDB_DTYPE_UTF8_STRING:
        string =
            strndup((char *)entry_data_list->entry_data.utf8_string,
                    entry_data_list->entry_data.data_size);
        if (NULL == string) {
            //return MMDB_OUT_OF_MEMORY;
        }
        print_indentation(indent);
        fprintf(stdout, "utf8_string = %s\n", string);
        free(string);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DTYPE_BYTES:
        bytes =
            strndup((char *)entry_data_list->entry_data.bytes,
                    entry_data_list->entry_data.data_size);
        if (NULL == bytes) {
            //return MMDB_OUT_OF_MEMORY;
        }
        print_indentation(indent);
        fprintf(stdout, "bytes = %s\n", bytes);
        free(bytes);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DTYPE_DOUBLE:
        print_indentation(indent);
        fprintf(stdout, "double = %f\n",
                entry_data_list->entry_data.double_value);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DTYPE_FLOAT:
        print_indentation(indent);
        fprintf(stdout, "float = %f\n",
                entry_data_list->entry_data.float_value);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DTYPE_UINT16:
        print_indentation(indent);
        fprintf(stdout, "uint16 = %u\n", entry_data_list->entry_data.uint16);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DTYPE_UINT32:
        print_indentation(indent);
        fprintf(stdout, "uint32 = %u\n",
                (uint32_t)entry_data_list->entry_data.uint32);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DTYPE_BOOLEAN:
        print_indentation(indent);
        fprintf(stdout, "boolean = %u\n",
                (uint32_t)entry_data_list->entry_data.boolean);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DTYPE_UINT64:
        print_indentation(indent);
        fprintf(stdout, "uint64 = XXX\n");
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DTYPE_UINT128:
        print_indentation(indent);
        fprintf(stdout, "uint128 = XXX\n");
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DTYPE_INT32:
        print_indentation(indent);
        fprintf(stdout, "int32 = %d\n", entry_data_list->entry_data.int32);
        entry_data_list = entry_data_list->next;
        break;
    default:
        MMDB_DBG_CARP("unknown type! %d\n", entry_data_list->entry_data.type);
        assert(0);
    }

    return entry_data_list;
}

LOCAL void print_indentation(int i)
{
    char buffer[1024];
    int size = i >= 1024 ? 1023 : i;
    memset(buffer, 32, size);
    buffer[size] = '\0';
    fputs(buffer, stderr);
}

const char *MMDB_strerror(uint16_t error_code)
{
    if (MMDB_SUCCESS == error_code) {
        return "Success (not an error)";
    } else if (MMDB_FILE_OPEN_ERROR == error_code) {
        return "Error opening the specified MaxMind DB file";
    } else if (MMDB_CORRUPT_DATABASE == error_code) {
        return "The MaxMind DB file's search tree is corrupt";
    } else if (MMDB_INVALID_DATABASE == error_code) {
        return "The MaxMind DB file is invalid (bad metadata)";
    } else if (MMDB_IO_ERROR == error_code) {
        return "An attempt to read data from the MaxMind DB file failed";
    } else if (MMDB_OUT_OF_MEMORY == error_code) {
        return "A memory allocation call failed";
    } else if (MMDB_UNKNOWN_DATABASE_FORMAT == error_code) {
        return
            "The MaxMind DB file is in a format this library can't handle (unknown record size or binary format version)";
    }
}
