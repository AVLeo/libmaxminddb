#include "maxminddb.h"
#include <arpa/inet.h>
#include <assert.h>
#include <fcntl.h>
#include <netdb.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <unistd.h>

#if HAVE_CONFIG_H
#include <config.h>
#endif

#if MMDB_DEBUG
#define LOCAL
#else
#define LOCAL static
#endif

typedef union {
    struct in_addr v4;
    struct in6_addr v6;
} in_addr_any;

#define MMDB_DATA_SECTION_SEPARATOR (16)

#define METADATA_MARKER "\xab\xcd\xefMaxMind.com"
/* This is 128kb */
#define METADATA_BLOCK_MAX_SIZE 131072

/* --prototypes automatically generated by dev-bin/regen-prototypes.pl - don't remove this comment */
LOCAL int resolve_any_address(const char *ipstr, int is_ipv4,
                              in_addr_any *in_addr);
LOCAL int find_address_in_search_tree(MMDB_s *mmdb, uint8_t *address,
                                      MMDB_lookup_result_s *result);
LOCAL uint32_t get_left_28_bit_record(const uint8_t *record);
LOCAL uint32_t get_right_28_bit_record(const uint8_t *record);
LOCAL int read_metadata(MMDB_s *mmdb, uint8_t *last_128kb, ssize_t size);
LOCAL const uint8_t *find_metadata(uint8_t *last_128kb, ssize_t size);
LOCAL uint32_t value_for_key_as_uint16(MMDB_entry_s *start, char *key);
LOCAL uint32_t value_for_key_as_uint32(MMDB_entry_s *start, char *key);
LOCAL uint64_t value_for_key_as_uint64(MMDB_entry_s *start, char *key);
LOCAL char *value_for_key_as_string(MMDB_entry_s *start, char *key);
LOCAL int populate_languages_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
                                      MMDB_entry_s *metadata_start);
LOCAL int populate_description_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
                                        MMDB_entry_s *metadata_start);
LOCAL uint16_t init(MMDB_s *mmdb, const char *filename, uint32_t flags);
LOCAL void free_mmdb_struct(MMDB_s *mmdb);
LOCAL void free_languages_metadata(MMDB_s *mmdb);
LOCAL void free_descriptions_metadata(MMDB_s *mmdb);
LOCAL int skip_hash_array(MMDB_s *mmdb, MMDB_entry_data_s *entry_data);
LOCAL int decode_one_follow(MMDB_s *mmdb, uint32_t offset,
                            MMDB_entry_data_s *entry_data);
LOCAL int decode_one(MMDB_s *mmdb, uint32_t offset,
                     MMDB_entry_data_s *entry_data);
LOCAL int get_ext_type(int raw_ext_type);
LOCAL void DPRINT_KEY(MMDB_s *mmdb, MMDB_entry_data_s *entry_data);
LOCAL uint32_t get_ptr_from(uint8_t ctrl, uint8_t const *const ptr,
                            int ptr_size);
LOCAL int get_entry_data_list(MMDB_s *mmdb, uint32_t offset,
                              MMDB_entry_data_list_s *entry_data_list);
LOCAL float get_ieee754_float(const uint8_t *restrict p);
LOCAL double get_ieee754_double(const uint8_t *restrict p);
LOCAL uint32_t get_uint32(const uint8_t *p);
LOCAL uint32_t get_uint24(const uint8_t *p);
LOCAL uint32_t get_uint16(const uint8_t *p);
LOCAL uint64_t get_uintX(const uint8_t *p, int length);
LOCAL int32_t get_sintX(const uint8_t *p, int length);
LOCAL int int_pread(int fd, uint8_t *buffer, ssize_t to_read, off_t offset);
LOCAL MMDB_entry_data_list_s *dump_entry_data_list(FILE *stream, MMDB_entry_data_list_s
                                                   *entry_data_list, int indent,
                                                   int *status);
LOCAL void print_indentation(FILE *stream, int i);
LOCAL char *bytes_to_hex(uint8_t *bytes, uint32_t size);
/* --prototypes end - don't remove this comment-- */

#define CHECKED_DECODE_ONE(mmdb, offset, entry_data)         \
    do {                                                     \
        int status = decode_one(mmdb, offset, entry_data);   \
        if (MMDB_SUCCESS != status) {                        \
            return status;                                   \
        }                                                    \
    } while (0);

#define CHECKED_DECODE_ONE_FOLLOW(mmdb, offset, entry_data)       \
    do {                                                          \
        int status = decode_one_follow(mmdb, offset, entry_data); \
        if (MMDB_SUCCESS != status) {                             \
            return status;                                        \
        }                                                         \
    } while (0);

#if !defined HAVE_MEMMEM
LOCAL void *memmem(const void *big, size_t big_len, const void *little,
                   size_t little_len)
{
    if (little_len) {
        int first_char = ((uint8_t *)little)[0];
        const void *ptr = big;
        size_t len = big_len;
        while (len >= little_len
               && (ptr = memchr(ptr, first_char, len - little_len + 1))) {
            if (!memcmp(ptr, little, little_len)) {
                return (void *)ptr;
            }
            len = big_len - (++ptr - big);
        }
    }
    return NULL;
}
#endif

MMDB_lookup_result_s MMDB_lookup_string(MMDB_s *mmdb, const char *ipstr,
                                        int *gai_error, int *mmdb_error)
{
    int is_ipv4 = mmdb->metadata.ip_version == 4 ? 1 : 0;
    in_addr_any in_addr;

    MMDB_lookup_result_s result = {
        .found_entry = false,
        .entry.mmdb = mmdb,
    };

    *gai_error = resolve_any_address(ipstr, is_ipv4, &in_addr);

    if (*gai_error) {
        return result;
    }

    uint8_t *address;
    if (is_ipv4) {
        address = (uint8_t *)&in_addr.v4.s_addr;
    } else {
        address = (uint8_t *)&in_addr.v6.s6_addr;
    }

    *mmdb_error = find_address_in_search_tree(mmdb, address, &result);

    return result;
}

LOCAL int resolve_any_address(const char *ipstr, int is_ipv4,
                              in_addr_any *in_addr)
{
    int ai_flags = AI_NUMERICHOST;
    struct addrinfo hints = {
        .ai_socktype = SOCK_STREAM
    };
    struct addrinfo *addresses;
    int gai_status;

    if (is_ipv4) {
        hints.ai_flags = ai_flags;
        hints.ai_family = AF_INET;
    } else {
        hints.ai_flags = ai_flags | AI_V4MAPPED;
        hints.ai_family = AF_INET6;
    }

    gai_status = getaddrinfo(ipstr, NULL, &hints, &addresses);
    if (gai_status) {
        return gai_status;
    }

    if (hints.ai_family == AF_INET) {
        memcpy(&in_addr->v4.s_addr,
               &((struct sockaddr_in *)addresses->ai_addr)->sin_addr.s_addr, 4);
    } else if (hints.ai_family == AF_INET6) {
        memcpy(&in_addr->v6.s6_addr,
               ((struct sockaddr_in6 *)addresses->ai_addr)->sin6_addr.s6_addr,
               16);
    } else {
        /* This should never happen */
        assert(0);
    }

    freeaddrinfo(addresses);

    return 0;
}

LOCAL int find_address_in_search_tree(MMDB_s *mmdb, uint8_t *address,
                                      MMDB_lookup_result_s *result)
{
    uint16_t record_length = mmdb->full_record_byte_size;
    uint32_t (*left_record_value) (const uint8_t *);
    uint32_t (*right_record_value) (const uint8_t *);
    uint8_t right_record_offset;

    if (record_length == 6) {
        left_record_value = &get_uint24;
        right_record_value = &get_uint24;
        right_record_offset = 3;
    } else if (record_length == 7) {
        left_record_value = &get_left_28_bit_record;
        right_record_value = &get_right_28_bit_record;
        right_record_offset = 3;
    } else if (record_length == 8) {
        left_record_value = &get_uint32;
        right_record_value = &get_uint32;
        right_record_offset = 4;
    }

    uint32_t node_count = mmdb->metadata.node_count;
    uint32_t value = 0;
    const uint8_t *search_tree = mmdb->file_content;
    uint16_t max_depth0 = mmdb->depth - 1;
    const uint8_t *record_pointer;
    for (uint16_t current_bit = max_depth0; current_bit >= 0; current_bit--) {
        record_pointer = &search_tree[value * record_length];
        if (address[(max_depth0 - current_bit) >> 3] &
            (1U << (~(max_depth0 - current_bit) & 7))) {

            record_pointer += right_record_offset;
            value = right_record_value(record_pointer);
        } else {
            value = left_record_value(record_pointer);
        }

        if (value >= node_count) {
            result->netmask = mmdb->depth - current_bit;
            result->entry.offset = value - node_count;
            result->found_entry = result->entry.offset > 0 ? true : false;
            return MMDB_SUCCESS;
        }
    }

    // We should not be able to reach this return. If we do, something very bad happened.
    return MMDB_CORRUPT_SEARCH_TREE_ERROR;
}

LOCAL uint32_t get_left_28_bit_record(const uint8_t *record)
{
    return record[0] * 65536 + record[1] * 256 + record[2] +
        ((record[3] & 0xf0) << 20);
}

LOCAL uint32_t get_right_28_bit_record(const uint8_t *record)
{
    uint32_t value = get_uint32(record);
    return value & 0xfffffff;
}

LOCAL int read_metadata(MMDB_s *mmdb, uint8_t *last_128kb, ssize_t size)
{
    const uint8_t *metadata;
    metadata = find_metadata(last_128kb, size);
    if (NULL == metadata) {
        return MMDB_INVALID_METADATA_ERROR;
    }

    /* We need to create a fake MMDB_s struct in order to decode values from
       the metadata. The metadata is basically just like the data section, so we
       want to use the same functions we use for the data section to get metadata
       values. */
    MMDB_s metadata_db;
    metadata_db.data_section = metadata;

    MMDB_entry_s metadata_start;
    metadata_start.mmdb = &metadata_db;
    metadata_start.offset = 0;

    mmdb->metadata.node_count =
        value_for_key_as_uint32(&metadata_start, "node_count");

    mmdb->metadata.record_size =
        value_for_key_as_uint16(&metadata_start, "record_size");

    if (mmdb->metadata.record_size != 24 && mmdb->metadata.record_size != 28
        && mmdb->metadata.record_size != 32) {
        return MMDB_UNKNOWN_DATABASE_FORMAT_ERROR;
    }

    mmdb->metadata.ip_version =
        value_for_key_as_uint16(&metadata_start, "ip_version");

    mmdb->metadata.database_type =
        value_for_key_as_string(&metadata_start, "database_type");

    int status =
        populate_languages_metadata(mmdb, &metadata_db, &metadata_start);
    if (MMDB_SUCCESS != status) {
        return status;
    }

    mmdb->metadata.binary_format_major_version =
        value_for_key_as_uint16(&metadata_start, "binary_format_major_version");

    mmdb->metadata.binary_format_minor_version =
        value_for_key_as_uint16(&metadata_start, "binary_format_minor_version");

    mmdb->metadata.build_epoch =
        value_for_key_as_uint64(&metadata_start, "build_epoch");

    status = populate_description_metadata(mmdb, &metadata_db, &metadata_start);
    if (MMDB_SUCCESS != status) {
        return status;
    }

    mmdb->full_record_byte_size = mmdb->metadata.record_size * 2 / 8U;

    mmdb->depth = mmdb->metadata.ip_version == 4 ? 32 : 128;

    return MMDB_SUCCESS;
}

LOCAL const uint8_t *find_metadata(uint8_t *last_128kb, ssize_t size)
{
    uint8_t *tmp;
    do {
        tmp = memmem(last_128kb, size,
                     METADATA_MARKER, strlen(METADATA_MARKER));

        if (NULL != tmp) {
            size -= tmp - last_128kb;
            last_128kb = tmp;
        }
    } while (NULL != tmp && tmp != last_128kb);

    return last_128kb + strlen(METADATA_MARKER);
}

LOCAL uint32_t value_for_key_as_uint16(MMDB_entry_s *start, char *key)
{
    MMDB_entry_data_s entry_data;
    MMDB_get_value(start, &entry_data, key, NULL);
    return entry_data.uint16;
}

LOCAL uint32_t value_for_key_as_uint32(MMDB_entry_s *start, char *key)
{
    MMDB_entry_data_s entry_data;
    MMDB_get_value(start, &entry_data, key, NULL);
    return entry_data.uint32;
}

LOCAL uint64_t value_for_key_as_uint64(MMDB_entry_s *start, char *key)
{
    MMDB_entry_data_s entry_data;
    MMDB_get_value(start, &entry_data, key, NULL);
    return entry_data.uint64;
}

LOCAL char *value_for_key_as_string(MMDB_entry_s *start, char *key)
{
    MMDB_entry_data_s entry_data;
    MMDB_get_value(start, &entry_data, key, NULL);
    return strndup((char *)entry_data.utf8_string, entry_data.data_size);
}

LOCAL int populate_languages_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
                                      MMDB_entry_s *metadata_start)
{
    MMDB_entry_data_s entry_data;

    MMDB_get_value(metadata_start, &entry_data, "languages", NULL);

    if (MMDB_DATA_TYPE_ARRAY != entry_data.type) {
        return MMDB_INVALID_METADATA_ERROR;
    }

    MMDB_entry_s array_start;
    array_start.mmdb = metadata_db;
    array_start.offset = entry_data.offset;

    MMDB_entry_data_list_s *member;
    MMDB_get_entry_data_list(&array_start, &member);

    MMDB_entry_data_list_s *first_member = member;

    uint32_t array_size = member->entry_data.data_size;
    mmdb->metadata.languages.count = 0;
    mmdb->metadata.languages.names = malloc(array_size * sizeof(char *));
    if (NULL == mmdb->metadata.languages.names) {
        return MMDB_OUT_OF_MEMORY_ERROR;
    }

    for (int i = 0; i < array_size; i++) {
        member = member->next;
        if (MMDB_DATA_TYPE_UTF8_STRING != member->entry_data.type) {
            return MMDB_INVALID_METADATA_ERROR;
        }

        mmdb->metadata.languages.names[i] =
            strndup((char *)member->entry_data.utf8_string,
                    member->entry_data.data_size);

        if (NULL == mmdb->metadata.languages.names[i]) {
            return MMDB_OUT_OF_MEMORY_ERROR;
        }
        // We assign this as we go so that if we fail a malloc and need to
        // free it, the count is right.
        mmdb->metadata.languages.count = i + 1;
    }

    MMDB_free_entry_data_list(first_member);

    return MMDB_SUCCESS;
}

LOCAL int populate_description_metadata(MMDB_s *mmdb, MMDB_s *metadata_db,
                                        MMDB_entry_s *metadata_start)
{
    MMDB_entry_data_s entry_data;

    MMDB_get_value(metadata_start, &entry_data, "description", NULL);

    if (MMDB_DATA_TYPE_MAP != entry_data.type) {
        return MMDB_INVALID_METADATA_ERROR;
    }

    MMDB_entry_s map_start;
    map_start.mmdb = metadata_db;
    map_start.offset = entry_data.offset;

    MMDB_entry_data_list_s *member;
    MMDB_get_entry_data_list(&map_start, &member);

    MMDB_entry_data_list_s *first_member = member;

    uint32_t map_size = member->entry_data.data_size;
    mmdb->metadata.description.count = 0;
    mmdb->metadata.description.descriptions =
        malloc(map_size * sizeof(MMDB_description_s *));
    if (NULL == mmdb->metadata.description.descriptions) {
        return MMDB_OUT_OF_MEMORY_ERROR;
    }

    for (int i = 0; i < map_size; i++) {
        mmdb->metadata.description.descriptions[i] =
            malloc(sizeof(MMDB_description_s));
        if (NULL == mmdb->metadata.description.descriptions[i]) {
            return MMDB_OUT_OF_MEMORY_ERROR;
        }

        mmdb->metadata.description.count = i + 1;
        mmdb->metadata.description.descriptions[i]->language = NULL;
        mmdb->metadata.description.descriptions[i]->description = NULL;

        member = member->next;

        if (MMDB_DATA_TYPE_UTF8_STRING != member->entry_data.type) {
            return MMDB_INVALID_METADATA_ERROR;
        }

        mmdb->metadata.description.descriptions[i]->language =
            strndup((char *)member->entry_data.utf8_string,
                    member->entry_data.data_size);

        if (NULL == mmdb->metadata.description.descriptions[i]->language) {
            return MMDB_OUT_OF_MEMORY_ERROR;
        }

        member = member->next;

        if (MMDB_DATA_TYPE_UTF8_STRING != member->entry_data.type) {
            return MMDB_INVALID_METADATA_ERROR;
        }

        mmdb->metadata.description.descriptions[i]->description =
            strndup((char *)member->entry_data.utf8_string,
                    member->entry_data.data_size);

        if (NULL == mmdb->metadata.description.descriptions[i]->description) {
            return MMDB_OUT_OF_MEMORY_ERROR;
        }
    }

    MMDB_free_entry_data_list(first_member);

    return MMDB_SUCCESS;
}

MMDB_s *MMDB_new_mmdb()
{
    return calloc(1, sizeof(MMDB_s));
}

uint16_t MMDB_open(const char *filename, uint32_t flags, MMDB_s *mmdb)
{
    MMDB_DBG_CARP("MMDB_open %s %d\n", filename, flags);
    return init(mmdb, filename, flags);
}

LOCAL uint16_t init(MMDB_s *mmdb, const char *filename, uint32_t flags)
{
    mmdb->filename = NULL;
    mmdb->file_content = NULL;
    mmdb->data_section = NULL;

    mmdb->filename = strdup(filename);
    if (mmdb->filename == NULL) {
        free_mmdb_struct(mmdb);
        return MMDB_OUT_OF_MEMORY_ERROR;
    }

    int fd = open(filename, O_RDONLY);
    if (fd < 0) {
        free_mmdb_struct(mmdb);
        return MMDB_FILE_OPEN_ERROR;
    }

    struct stat s;
    fstat(fd, &s);

    if ((flags & MMDB_MODE_MASK) == 0) {
        flags |= MMDB_MODE_MMAP;
    }
    mmdb->flags = flags;
    ssize_t size;
    mmdb->file_size = size = s.st_size;

    uint8_t *last_128kb = malloc(METADATA_BLOCK_MAX_SIZE);
    if (NULL == last_128kb) {
        free_mmdb_struct(mmdb);
        return MMDB_OUT_OF_MEMORY_ERROR;
    }

    off_t offset = size > METADATA_BLOCK_MAX_SIZE ? METADATA_BLOCK_MAX_SIZE : 0;
    if (MMDB_SUCCESS != int_pread(fd, last_128kb, size, offset)) {
        free_mmdb_struct(mmdb);
        return MMDB_IO_ERROR;
    }

    int status = read_metadata(mmdb, last_128kb, size);
    free(last_128kb);
    if (MMDB_SUCCESS != status) {
        free_mmdb_struct(mmdb);
        return status;
    }

    if (mmdb->metadata.binary_format_major_version != 2) {
        free_mmdb_struct(mmdb);
        return MMDB_UNKNOWN_DATABASE_FORMAT_ERROR;
    }

    uint8_t *file_content;
    if ((flags & MMDB_MODE_MASK) == MMDB_MODE_MEMORY_CACHE) {
        file_content = malloc(size);
        if (NULL == file_content) {
            free_mmdb_struct(mmdb);
            return MMDB_OUT_OF_MEMORY_ERROR;
        }
        if (MMDB_SUCCESS != int_pread(fd, file_content, size, 0)) {
            free_mmdb_struct(mmdb);
            return MMDB_IO_ERROR;
        }
    } else {
        file_content =
            (uint8_t *)mmap(NULL, size, PROT_READ, MAP_SHARED, fd, 0);
        if (MAP_FAILED == file_content) {
            free_mmdb_struct(mmdb);
            return MMDB_IO_ERROR;
        }
    }

    close(fd);

    mmdb->file_content = file_content;
    mmdb->data_section =
        file_content + mmdb->metadata.node_count * mmdb->full_record_byte_size;

    return MMDB_SUCCESS;
}

void MMDB_close(MMDB_s *mmdb)
{
    free_mmdb_struct(mmdb);
}

LOCAL void free_mmdb_struct(MMDB_s *mmdb)
{
    if (!mmdb) {
        return;
    }

    if (NULL != mmdb->filename) {
        free(mmdb->filename);
    }
    if (NULL != mmdb->file_content) {
        if ((mmdb->flags & MMDB_MODE_MASK) == MMDB_MODE_MEMORY_CACHE) {
            free((void *)mmdb->file_content);
        } else {
            munmap((void *)mmdb->file_content, mmdb->file_size);
        }
    }

    if (NULL != mmdb->metadata.database_type) {
        free(mmdb->metadata.database_type);
    }

    free_languages_metadata(mmdb);
    free_descriptions_metadata(mmdb);
}

LOCAL void free_languages_metadata(MMDB_s *mmdb)
{
    if (!mmdb->metadata.languages.count) {
        return;
    }

    for (int i = 0; i < mmdb->metadata.languages.count; i++) {
        free((char *)mmdb->metadata.languages.names[i]);
    }
    free(mmdb->metadata.languages.names);
}

LOCAL void free_descriptions_metadata(MMDB_s *mmdb)
{
    if (!mmdb->metadata.description.count) {
        return;
    }

    for (size_t i = 0; i < mmdb->metadata.description.count; i++) {
        if (NULL != mmdb->metadata.description.descriptions[i]) {
            if (NULL != mmdb->metadata.description.descriptions[i]->language) {
                free((char *)mmdb->metadata.description.descriptions[i]->
                     language);
            }

            if (NULL != mmdb->metadata.description.descriptions[i]->description) {
                free((char *)mmdb->metadata.description.
                     descriptions[i]->description);
            }
            free(mmdb->metadata.description.descriptions[i]);
        }
    }

    free(mmdb->metadata.description.descriptions);
}

int MMDB_get_value(MMDB_entry_s *start, MMDB_entry_data_s *entry_data, ...)
{
    va_list keys;
    va_start(keys, entry_data);
    int status = MMDB_vget_value(start, entry_data, keys);
    va_end(keys);
    return status;
}

int MMDB_vget_value(MMDB_entry_s *start, MMDB_entry_data_s *entry_data,
                    va_list params)
{
    MMDB_entry_data_s key, value;
    MMDB_s *mmdb = start->mmdb;
    uint32_t offset = start->offset;
    char *src_key;

    memset(entry_data, 0, sizeof(MMDB_entry_data_s));

    do {
        CHECKED_DECODE_ONE(mmdb, offset, entry_data);

        src_key = va_arg(params, char *);
        MMDB_DBG_CARP("decode_one src_key:%s\n", src_key);

        if (NULL == src_key) {
            goto end;
        }

        size_t src_keylen;
 one_key:
        src_keylen = strlen(src_key);
        switch (entry_data->type) {
        case MMDB_DATA_TYPE_PTR:
            CHECKED_DECODE_ONE(mmdb, entry_data->pointer, entry_data);
            break;

            /* XXX - it'd be good to find a quicker way to skip through these
               entries that doesn't involve decoding them
               completely. Basically we need to just use the size from the
               control byte to advance our pointer rather than calling
               decode_one(). */
        case MMDB_DATA_TYPE_ARRAY:
            {
                uint32_t size = entry_data->data_size;
                int offset = strtol(src_key, NULL, 10);
                if (offset >= size || offset < 0) {
                    entry_data->offset = 0;
                    goto end;
                }
                for (int i = 0; i < offset; i++) {
                    CHECKED_DECODE_ONE(mmdb, entry_data->offset_to_next,
                                       entry_data);
                    int status = skip_hash_array(mmdb, entry_data);
                    if (MMDB_SUCCESS != status) {
                        return status;
                    }
                }
                if (src_key = va_arg(params, char *)) {
                    CHECKED_DECODE_ONE_FOLLOW(mmdb, entry_data->offset_to_next,
                                              entry_data);
                    offset = entry_data->offset_to_next;
                    goto one_key;
                }
                CHECKED_DECODE_ONE_FOLLOW(mmdb, entry_data->offset_to_next,
                                          &value);
                memcpy(entry_data, &value, sizeof(MMDB_entry_data_s));
                goto end;
            }
            break;
        case MMDB_DATA_TYPE_MAP:
            {
                uint32_t size = entry_data->data_size;
                offset = entry_data->offset_to_next;
                while (size-- > 0) {
                    CHECKED_DECODE_ONE(mmdb, offset, &key);

                    uint32_t offset_to_value = key.offset_to_next;

                    if (key.type == MMDB_DATA_TYPE_PTR) {
                        CHECKED_DECODE_ONE(mmdb, key.pointer, &key);
                    }

                    if (MMDB_DATA_TYPE_UTF8_STRING != key.type) {
                        return MMDB_INVALID_DATA_ERROR;
                    }

                    if (key.data_size == src_keylen &&
                        !memcmp(src_key, key.utf8_string, src_keylen)) {

                        if (src_key = va_arg(params, char *)) {
                            CHECKED_DECODE_ONE_FOLLOW(mmdb, offset_to_value,
                                                      entry_data);
                            offset = entry_data->offset_to_next;

                            goto one_key;
                        }
                        CHECKED_DECODE_ONE_FOLLOW(mmdb, offset_to_value,
                                                  &value);
                        memcpy(entry_data, &value, sizeof(MMDB_entry_data_s));
                        goto end;
                    } else {
                        CHECKED_DECODE_ONE(mmdb, offset_to_value, &value);
                        int status = skip_hash_array(mmdb, &value);
                        if (MMDB_SUCCESS != status) {
                            return status;
                        }
                        offset = value.offset_to_next;
                    }
                }

                entry_data->offset = 0;
                goto end;
            }
        default:
            break;
        }
    }
    while (src_key);

 end:
    va_end(params);
    return MMDB_SUCCESS;
}

LOCAL int skip_hash_array(MMDB_s *mmdb, MMDB_entry_data_s *entry_data)
{
    if (entry_data->type == MMDB_DATA_TYPE_MAP) {
        uint32_t size = entry_data->data_size;
        while (size-- > 0) {
            CHECKED_DECODE_ONE(mmdb, entry_data->offset_to_next, entry_data);   // key
            CHECKED_DECODE_ONE(mmdb, entry_data->offset_to_next, entry_data);   // value
            skip_hash_array(mmdb, entry_data);
        }

    } else if (entry_data->type == MMDB_DATA_TYPE_ARRAY) {
        uint32_t size = entry_data->data_size;
        while (size-- > 0) {
            CHECKED_DECODE_ONE(mmdb, entry_data->offset_to_next, entry_data);   // value
            skip_hash_array(mmdb, entry_data);
        }
    }

    return MMDB_SUCCESS;
}

LOCAL int decode_one_follow(MMDB_s *mmdb, uint32_t offset,
                            MMDB_entry_data_s *entry_data)
{
    CHECKED_DECODE_ONE(mmdb, offset, entry_data);
    if (entry_data->type == MMDB_DATA_TYPE_PTR) {
        CHECKED_DECODE_ONE(mmdb, entry_data->pointer, entry_data);
    }
}

LOCAL int decode_one(MMDB_s *mmdb, uint32_t offset,
                     MMDB_entry_data_s *entry_data)
{
    const uint8_t *mem = mmdb->data_section;
    entry_data->offset = offset;
    uint8_t ctrl = mem[offset++];
    int type = (ctrl >> 5) & 7;
    if (type == MMDB_DATA_TYPE_EXT) {
        type = get_ext_type(mem[offset++]);
    }

    entry_data->type = type;

    if (type == MMDB_DATA_TYPE_PTR) {
        int psize = (ctrl >> 3) & 3;
        entry_data->pointer = get_ptr_from(ctrl, &mem[offset], psize);
        entry_data->data_size = psize + 1;
        entry_data->offset_to_next = offset + psize + 1;
        MMDB_DBG_CARP
            ("decode_one{ptr} ctrl:%d, offset:%d psize:%d point_to:%d\n", ctrl,
             offset, psize, entry_data->pointer);
        return MMDB_SUCCESS;
    }

    uint32_t size = ctrl & 31;
    switch (size) {
    case 29:
        size = 29 + mem[offset++];
        break;
    case 30:
        size = 285 + get_uint16(&mem[offset]);
        offset += 2;
        break;
    case 31:
        size = 65821 + get_uint24(&mem[offset]);
        offset += 3;
    default:
        break;
    }

    if (type == MMDB_DATA_TYPE_MAP || type == MMDB_DATA_TYPE_ARRAY) {
        entry_data->data_size = size;
        entry_data->offset_to_next = offset;
        MMDB_DBG_CARP("decode_one type:%d size:%d\n", type, size);
        return MMDB_SUCCESS;
    }

    if (type == MMDB_DATA_TYPE_BOOLEAN) {
        entry_data->boolean = size ? true : false;
        entry_data->data_size = 0;
        entry_data->offset_to_next = offset;
        MMDB_DBG_CARP("decode_one type:%d size:%d\n", type, 0);
        return MMDB_SUCCESS;
    }

    if (size == 0 && type != MMDB_DATA_TYPE_UINT16
        && type != MMDB_DATA_TYPE_UINT32 && type != MMDB_DATA_TYPE_INT32) {
        entry_data->bytes = NULL;
        entry_data->utf8_string = NULL;
        entry_data->data_size = 0;
        entry_data->offset_to_next = offset;
        return MMDB_SUCCESS;
    }

    if (type == MMDB_DATA_TYPE_UINT16) {
        if (size < 0 || size > 2) {
            return MMDB_INVALID_DATA_ERROR;
        }
        entry_data->uint16 = (uint16_t)get_uintX(&mem[offset], size);
    } else if (type == MMDB_DATA_TYPE_UINT32) {
        if (size < 0 || size > 4) {
            return MMDB_INVALID_DATA_ERROR;
        }
        entry_data->uint32 = (uint32_t)get_uintX(&mem[offset], size);
    } else if (type == MMDB_DATA_TYPE_INT32) {
        if (size < 0 || size > 4) {
            return MMDB_INVALID_DATA_ERROR;
        }
        entry_data->int32 = get_sintX(&mem[offset], size);
    } else if (type == MMDB_DATA_TYPE_UINT64) {
        if (size < 0 || size > 8) {
            return MMDB_INVALID_DATA_ERROR;
        }
        entry_data->uint64 = get_uintX(&mem[offset], size);
    } else if (type == MMDB_DATA_TYPE_UINT128) {
        if (size < 0 || size > 16) {
            return MMDB_INVALID_DATA_ERROR;
        }

        memset(entry_data->uint128, 0, 16);
        if (size > 0) {
            memcpy(entry_data->uint128 + 16 - size, &mem[offset], size);
        }
    } else if (type == MMDB_DATA_TYPE_FLOAT) {
        size = 4;
        entry_data->float_value = get_ieee754_float(&mem[offset]);
    } else if (type == MMDB_DATA_TYPE_DOUBLE) {
        size = 8;
        entry_data->double_value = get_ieee754_double(&mem[offset]);
    } else if (type == MMDB_DATA_TYPE_UTF8_STRING) {
        entry_data->utf8_string = &mem[offset];
        entry_data->data_size = size;
    } else if (type == MMDB_DATA_TYPE_BYTES) {
        entry_data->bytes = &mem[offset];
        entry_data->data_size = size;
    }
    entry_data->offset_to_next = offset + size;
    MMDB_DBG_CARP("decode_one type:%d size:%d\n", type, size);

    return MMDB_SUCCESS;
}

LOCAL int get_ext_type(int raw_ext_type)
{
    return 7 + raw_ext_type;
}

LOCAL void DPRINT_KEY(MMDB_s *mmdb, MMDB_entry_data_s *entry_data)
{
    uint32_t len = entry_data->data_size > 255 ? 255 : entry_data->data_size;

    uint8_t str[256];
    memcpy(str, entry_data->utf8_string, len);

    str[len] = '\0';
    fprintf(stderr, "%s\n", str);
}

LOCAL uint32_t get_ptr_from(uint8_t ctrl, uint8_t const *const ptr,
                            int ptr_size)
{
    uint32_t new_offset;
    switch (ptr_size) {
    case 0:
        new_offset = (ctrl & 7) * 256 + ptr[0];
        break;
    case 1:
        new_offset = 2048 + (ctrl & 7) * 65536 + ptr[0] * 256 + ptr[1];
        break;
    case 2:
        new_offset = 2048 + 524288 + (ctrl & 7) * 16777216 + get_uint24(ptr);
        break;
    case 3:
    default:
        new_offset = get_uint32(ptr);
        break;
    }
    return MMDB_DATA_SECTION_SEPARATOR + new_offset;
}

int MMDB_get_entry_data_list(MMDB_entry_s *start,
                             MMDB_entry_data_list_s **entry_data_list)
{
    *entry_data_list = MMDB_new_entry_data_list();
    if (NULL == &entry_data_list) {
        return MMDB_OUT_OF_MEMORY_ERROR;
    }
    return get_entry_data_list(start->mmdb, start->offset, *entry_data_list);
}

LOCAL int get_entry_data_list(MMDB_s *mmdb, uint32_t offset,
                              MMDB_entry_data_list_s *entry_data_list)
{
    CHECKED_DECODE_ONE(mmdb, offset, &entry_data_list->entry_data);

    switch (entry_data_list->entry_data.type) {
    case MMDB_DATA_TYPE_PTR:
        {
            MMDB_DBG_CARP("Skip ptr\n");
            uint32_t next_offset = entry_data_list->entry_data.offset_to_next;
            uint32_t last_offset;
            while (entry_data_list->entry_data.type == MMDB_DATA_TYPE_PTR) {
                CHECKED_DECODE_ONE(mmdb, last_offset =
                                   entry_data_list->entry_data.pointer,
                                   &entry_data_list->entry_data);
            }

            if (entry_data_list->entry_data.type == MMDB_DATA_TYPE_ARRAY
                || entry_data_list->entry_data.type == MMDB_DATA_TYPE_MAP) {

                int status =
                    get_entry_data_list(mmdb, last_offset, entry_data_list);
                if (MMDB_SUCCESS != status) {
                    return status;
                }
            }
            entry_data_list->entry_data.offset_to_next = next_offset;
        }
        break;
    case MMDB_DATA_TYPE_ARRAY:
        {
            uint32_t array_size = entry_data_list->entry_data.data_size;
            MMDB_DBG_CARP("Decode array with %d entries\n", array_size);
            uint32_t array_offset = entry_data_list->entry_data.offset_to_next;
            MMDB_entry_data_list_s *previous = entry_data_list;
            while (array_size-- > 0) {
                MMDB_entry_data_list_s *entry_data_list_to = previous->next =
                    MMDB_new_entry_data_list();
                if (NULL == entry_data_list_to) {
                    return MMDB_OUT_OF_MEMORY_ERROR;
                }

                int status =
                    get_entry_data_list(mmdb, array_offset, entry_data_list_to);
                if (MMDB_SUCCESS != status) {
                    return status;
                }

                array_offset = entry_data_list_to->entry_data.offset_to_next;
                while (previous->next) {
                    previous = previous->next;
                }
            }
            entry_data_list->entry_data.offset_to_next = array_offset;

        }
        break;
    case MMDB_DATA_TYPE_MAP:
        {
            uint32_t size = entry_data_list->entry_data.data_size;

#if MMDB_DEBUG
            int rnd = rand();
            MMDB_DBG_CARP("%u decode hash with %d keys\n", rnd, size);
#endif
            offset = entry_data_list->entry_data.offset_to_next;
            MMDB_entry_data_list_s *previous = entry_data_list;
            while (size-- > 0) {
                MMDB_entry_data_list_s *entry_data_list_to = previous->next =
                    MMDB_new_entry_data_list();
                if (NULL == entry_data_list_to) {
                    return MMDB_OUT_OF_MEMORY_ERROR;
                }

                int status =
                    get_entry_data_list(mmdb, offset, entry_data_list_to);
                if (MMDB_SUCCESS != status) {
                    return status;
                }

                while (previous->next) {
                    previous = previous->next;
                }
#if MMDB_DEBUG
                MMDB_DBG_CARP("key num: %d (%u)", size, rnd);
                DPRINT_KEY(mmdb, &entry_data_list_to->entry_data);
#endif

                offset = entry_data_list_to->entry_data.offset_to_next;
                entry_data_list_to = previous->next =
                    MMDB_new_entry_data_list();

                if (NULL == entry_data_list_to) {
                    return MMDB_OUT_OF_MEMORY_ERROR;
                }

                status = get_entry_data_list(mmdb, offset, entry_data_list_to);
                if (MMDB_SUCCESS != status) {
                    return status;
                }

                while (previous->next) {
                    previous = previous->next;
                }
                offset = entry_data_list_to->entry_data.offset_to_next;
            }
            entry_data_list->entry_data.offset_to_next = offset;
        }
        break;
    default:
        break;
    }

    return MMDB_SUCCESS;
}

LOCAL float get_ieee754_float(const uint8_t *restrict p)
{
    volatile float f;
    uint8_t *q = (void *)&f;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    q[3] = p[0];
    q[2] = p[1];
    q[1] = p[2];
    q[0] = p[3];
#else
    memcpy(q, p, 4);
#endif
    return f;
}

LOCAL double get_ieee754_double(const uint8_t *restrict p)
{
    volatile double d;
    uint8_t *q = (void *)&d;
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    q[7] = p[0];
    q[6] = p[1];
    q[5] = p[2];
    q[4] = p[3];
    q[3] = p[4];
    q[2] = p[5];
    q[1] = p[6];
    q[0] = p[7];
#else
    memcpy(q, p, 8);
#endif

    return d;
}

LOCAL uint32_t get_uint32(const uint8_t *p)
{
    return (p[0] * 16777216U + p[1] * 65536 + p[2] * 256 + p[3]);
}

LOCAL uint32_t get_uint24(const uint8_t *p)
{
    return (p[0] * 65536U + p[1] * 256 + p[2]);
}

LOCAL uint32_t get_uint16(const uint8_t *p)
{
    return (p[0] * 256U + p[1]);
}

LOCAL uint64_t get_uintX(const uint8_t *p, int length)
{
    uint64_t value = 0;
    while (length-- > 0) {
        value <<= 8;
        value += *p++;
    }
    return value;
}

LOCAL int32_t get_sintX(const uint8_t *p, int length)
{
    return (int32_t)get_uintX(p, length);
}

LOCAL int int_pread(int fd, uint8_t *buffer, ssize_t to_read, off_t offset)
{
    while (to_read > 0) {
        ssize_t have_read = pread(fd, buffer, to_read, offset);
        if (have_read <= 0) {
            return MMDB_IO_ERROR;
        }
        to_read -= have_read;
        if (to_read == 0) {
            break;
        }
        offset += have_read;
        buffer += have_read;
    }
    return MMDB_SUCCESS;
}

MMDB_entry_data_list_s *MMDB_new_entry_data_list(void)
{
    return calloc(1, sizeof(MMDB_entry_data_list_s));
}

void MMDB_free_entry_data_list(MMDB_entry_data_list_s *entry_data_list)
{
    if (entry_data_list == NULL) {
        return;
    }
    if (entry_data_list->next) {
        MMDB_free_entry_data_list(entry_data_list->next);
    }
    free(entry_data_list);
}

const char *MMDB_lib_version(void)
{
    return PACKAGE_VERSION;
}

int MMDB_dump_entry_data_list(FILE *stream,
                              MMDB_entry_data_list_s *entry_data_list,
                              int indent)
{
    int status;
    dump_entry_data_list(stream, entry_data_list, indent, &status);
    return status;
}

LOCAL MMDB_entry_data_list_s *dump_entry_data_list(FILE *stream, MMDB_entry_data_list_s
                                                   *entry_data_list, int indent,
                                                   int *status)
{
    switch (entry_data_list->entry_data.type) {
    case MMDB_DATA_TYPE_MAP:
        {
            uint32_t size = entry_data_list->entry_data.data_size;

            print_indentation(stream, indent);
            fprintf(stream, "{\n");
            indent += 2;

            for (entry_data_list = entry_data_list->next;
                 size && entry_data_list; size--) {

                char *key =
                    strndup((char *)entry_data_list->entry_data.utf8_string,
                            entry_data_list->entry_data.data_size);
                if (NULL == key) {
                    *status = MMDB_OUT_OF_MEMORY_ERROR;
                    return NULL;
                }

                print_indentation(stream, indent);
                fprintf(stream, "\"%s\": \n", key);
                entry_data_list = entry_data_list->next;
                entry_data_list =
                    dump_entry_data_list(stream, entry_data_list, indent + 2,
                                         status);

                if (MMDB_SUCCESS != *status) {
                    return NULL;
                }
            }

            indent -= 2;
            print_indentation(stream, indent);
            fprintf(stream, "}\n");
        }
        break;
    case MMDB_DATA_TYPE_ARRAY:
        {
            uint32_t size = entry_data_list->entry_data.data_size;

            print_indentation(stream, indent);
            fprintf(stream, "[\n");
            indent += 2;

            for (entry_data_list = entry_data_list->next;
                 size && entry_data_list; size--) {
                entry_data_list =
                    dump_entry_data_list(stream, entry_data_list, indent,
                                         status);
                if (MMDB_SUCCESS != *status) {
                    return NULL;
                }
            }

            indent -= 2;
            print_indentation(stream, indent);
            fprintf(stream, "]\n");
        }
        break;
    case MMDB_DATA_TYPE_UTF8_STRING:
        {
            char *string =
                strndup((char *)entry_data_list->entry_data.utf8_string,
                        entry_data_list->entry_data.data_size);
            if (NULL == string) {
                *status = MMDB_OUT_OF_MEMORY_ERROR;
                return NULL;
            }
            print_indentation(stream, indent);
            fprintf(stream, "\"%s\" <utf8_string>\n", string);
            free(string);
            entry_data_list = entry_data_list->next;
        }
        break;
    case MMDB_DATA_TYPE_BYTES:
        {
            char *hex_string =
                bytes_to_hex((uint8_t *)entry_data_list->entry_data.bytes,
                             entry_data_list->entry_data.data_size);
            if (NULL == hex_string) {
                *status = MMDB_OUT_OF_MEMORY_ERROR;
                return NULL;
            }

            print_indentation(stream, indent);
            fprintf(stream, "%s <bytes>\n", hex_string);
            free(hex_string);

            entry_data_list = entry_data_list->next;
        }
        break;
    case MMDB_DATA_TYPE_DOUBLE:
        print_indentation(stream, indent);
        fprintf(stream, "%f <double>\n",
                entry_data_list->entry_data.double_value);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DATA_TYPE_FLOAT:
        print_indentation(stream, indent);
        fprintf(stream, "%f <float>\n",
                entry_data_list->entry_data.float_value);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DATA_TYPE_UINT16:
        print_indentation(stream, indent);
        fprintf(stream, "%u <uint16>\n", entry_data_list->entry_data.uint16);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DATA_TYPE_UINT32:
        print_indentation(stream, indent);
        fprintf(stream, "%u <uint32>\n", entry_data_list->entry_data.uint32);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DATA_TYPE_BOOLEAN:
        print_indentation(stream, indent);
        fprintf(stream, "%s <boolean>\n",
                entry_data_list->entry_data.boolean ? "true" : "false");
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DATA_TYPE_UINT64:
        print_indentation(stream, indent);
        fprintf(stream, "%lu <uint64>\n", entry_data_list->entry_data.uint64);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DATA_TYPE_UINT128:
        print_indentation(stream, indent);
        char *hex_string =
            bytes_to_hex((uint8_t *)entry_data_list->entry_data.uint128, 16);
        fprintf(stream, "%s <uint128>\n", hex_string);
        free(hex_string);
        entry_data_list = entry_data_list->next;
        break;
    case MMDB_DATA_TYPE_INT32:
        print_indentation(stream, indent);
        fprintf(stream, "%d <int32>\n", entry_data_list->entry_data.int32);
        entry_data_list = entry_data_list->next;
        break;
    default:
        MMDB_DBG_CARP("unknown type! %d\n", entry_data_list->entry_data.type);
        *status = MMDB_INVALID_DATA_ERROR;
        return NULL;
    }

    *status = MMDB_SUCCESS;
    return entry_data_list;
}

LOCAL void print_indentation(FILE *stream, int i)
{
    char buffer[1024];
    int size = i >= 1024 ? 1023 : i;
    memset(buffer, 32, size);
    buffer[size] = '\0';
    fputs(buffer, stream);
}

LOCAL char *bytes_to_hex(uint8_t *bytes, uint32_t size)
{
    char *hex_string = malloc((size * 2) + 1);
    char *hex_pointer = hex_string;

    for (uint32_t i = 0; i < size; i++) {
        hex_pointer += sprintf(hex_pointer, "%02X", bytes[i]);
    }
    *(hex_pointer + 1) = '\0';
    return hex_string;
}

const char *MMDB_strerror(uint16_t error_code)
{
    if (MMDB_SUCCESS == error_code) {
        return "Success (not an error)";
    } else if (MMDB_FILE_OPEN_ERROR == error_code) {
        return "Error opening the specified MaxMind DB file";
    } else if (MMDB_CORRUPT_SEARCH_TREE_ERROR == error_code) {
        return "The MaxMind DB file's search tree is corrupt";
    } else if (MMDB_INVALID_METADATA_ERROR == error_code) {
        return "The MaxMind DB file contains invalid metadata";
    } else if (MMDB_IO_ERROR == error_code) {
        return "An attempt to read data from the MaxMind DB file failed";
    } else if (MMDB_OUT_OF_MEMORY_ERROR == error_code) {
        return "A memory allocation call failed";
    } else if (MMDB_UNKNOWN_DATABASE_FORMAT_ERROR == error_code) {
        return
            "The MaxMind DB file is in a format this library can't handle (unknown record size or binary format version)";
    } else if (MMDB_INVALID_DATA_ERROR == error_code) {
        return
            "The MaxMind DB file's data section contains bad data (unknown data type or corrupt data)";
    } else {
        return "Unknown error code";
    }
}
